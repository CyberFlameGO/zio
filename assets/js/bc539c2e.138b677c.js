"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[67145],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>m});var a=t(67294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=a.createContext({}),c=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},p=function(e){var n=c(e.components);return a.createElement(s.Provider,{value:n},e.children)},u="mdxType",g={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},f=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=c(t),f=i,m=u["".concat(s,".").concat(f)]||u[f]||g[f]||o;return t?a.createElement(m,r(r({ref:n},p),{},{components:t})):a.createElement(m,r({ref:n},p))}));function m(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,r=new Array(o);r[0]=f;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l[u]="string"==typeof e?e:i,r[1]=l;for(var c=2;c<o;c++)r[c]=t[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}f.displayName="MDXCreateElement"},1591:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var a=t(87462),i=(t(67294),t(3905));const o={id:"manual-creation-of-config-descriptor",title:"Manual creation of ConfigDescriptor"},r=void 0,l={unversionedId:"zio-config/manual-creation-of-config-descriptor",id:"zio-config/manual-creation-of-config-descriptor",title:"Manual creation of ConfigDescriptor",description:"Config Descriptor is the core of your configuration management. You can write a description by hand, or rely on",source:"@site/docs/zio-config/manual-creation-of-config-descriptor.md",sourceDirName:"zio-config",slug:"/zio-config/manual-creation-of-config-descriptor",permalink:"/zio-config/manual-creation-of-config-descriptor",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/zio-config/manual-creation-of-config-descriptor.md",tags:[],version:"current",frontMatter:{id:"manual-creation-of-config-descriptor",title:"Manual creation of ConfigDescriptor"},sidebar:"ecosystem-sidebar",previous:{title:"Getting Started",permalink:"/zio-config/"},next:{title:"Automatic Derivation of ConfigDescriptor",permalink:"/zio-config/automatic-derivation-of-config-descriptor"}},s={},c=[{value:"A Simple example",id:"a-simple-example",level:2},{value:"Fully Automated Config Description: zio-config-magnolia",id:"fully-automated-config-description-zio-config-magnolia",level:2},{value:"Running the description to ZIO",id:"running-the-description-to-zio",level:2},{value:"Built-in types",id:"built-in-types",level:2},{value:"Optional Types",id:"optional-types",level:2},{value:"Default",id:"default",level:2},{value:"New types",id:"new-types",level:2},{value:"Multiple sources",id:"multiple-sources",level:2},{value:"Combining various effectful sources",id:"combining-various-effectful-sources",level:2},{value:"Either Types (orElseEither)",id:"either-types-orelseeither",level:2},{value:"OrElse",id:"orelse",level:2},{value:"Composing multiple configurations",id:"composing-multiple-configurations",level:2},{value:"Nesting",id:"nesting",level:2},{value:"CollectAll (Sequence)",id:"collectall-sequence",level:2},{value:"Handling list is just easy!",id:"handling-list-is-just-easy",level:2}],p={toc:c};function u(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Config Descriptor is the core of your configuration management. You can write a description by hand, or rely on\nzio-config-magnolia of zio-config-shapeless that can automatically generate the description for you, based on the case\nclasses (or sealed traits) that represents your config."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import zio.{ ZIO, IO, Layer }\nimport zio.config._, ConfigDescriptor._, ConfigSource._\n")),(0,i.kt)("h2",{id:"a-simple-example"},"A Simple example"),(0,i.kt)("p",null,"We must fetch the configuration from the environment to a case class (product) in scala. Let it be ",(0,i.kt)("inlineCode",{parentName:"p"},"MyConfig")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"case class MyConfig(ldap: String, port: Int, dburl: String)\n")),(0,i.kt)("p",null,"To perform any action using zio-config, we need a configuration description.\nLet's define a simple one."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'val myConfig: ConfigDescriptor[MyConfig] =\n  (string("LDAP") zip int("PORT") zip string("DB_URL")).to[MyConfig]\n')),(0,i.kt)("p",null,"Case classes with a single field are simple too."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'case class MySingleConfig(ldap: String)\n\nval mySingleConfig: ConfigDescriptor[MySingleConfig] =\n  string("LDAP").to[MySingleConfig]\n')),(0,i.kt)("p",null,"If the config is not a case class, but a tuple, then all you need to do is ",(0,i.kt)("inlineCode",{parentName:"p"},"zip")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'val mySingleConfigTupled: ConfigDescriptor[(String, Int)] =\n  (string("LDAP") zip int("PORT"))\n')),(0,i.kt)("p",null,"Think of this as removing fields one-by-one, along with the ",(0,i.kt)("inlineCode",{parentName:"p"},"zip")," combinator syntax, ending up with a single field being\napplied."),(0,i.kt)("h2",{id:"fully-automated-config-description-zio-config-magnolia"},"Fully Automated Config Description: zio-config-magnolia"),(0,i.kt)("p",null,"If you don't like describing your configuration manually, and rely on the names of the parameter in the case class (or\nsealed trait),\nthere is a separate module called ",(0,i.kt)("inlineCode",{parentName:"p"},"zio-config-magnolia")," which uses ",(0,i.kt)("inlineCode",{parentName:"p"},"Magnolia")," library to automatically derive the\ndescriptions for you."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import zio.config.magnolia._\n\nval myConfigAutomatic = descriptor[MyConfig]\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"myConfig")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"myConfigAutomatic")," are same description, and is of the same type."),(0,i.kt)("p",null,"If you need more control over the description,\nprobably you may choose to write it manually (such as, for adding extra documentations).\nMore examples on automatic derivation is in examples module of ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/zio/zio-config"},"zio-config")),(0,i.kt)("h2",{id:"running-the-description-to-zio"},"Running the description to ZIO"),(0,i.kt)("p",null,"To read a config, means it has to perform some effects, and for that reason, it returns with a ZIO.\nTo be specific it returns an ",(0,i.kt)("inlineCode",{parentName:"p"},"IO")," where ",(0,i.kt)("inlineCode",{parentName:"p"},"type IO[E, A] = ZIO[Any, E, A]")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import zio.System\n\n// That's system environment\nval result: Layer[ReadError[String], MyConfig] = ZConfig.fromSystemEnv(myConfig)\n")),(0,i.kt)("p",null,"Another way of doing this is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"val systemSource = ConfigSource.fromSystemEnv()\n\nread(myConfig from systemSource)\n")),(0,i.kt)("p",null,"You can run this to ",(0,i.kt)("a",{parentName:"p",href:"https://zio.dev/docs/getting_started.html#main"},"completion")," as in any zio application."),(0,i.kt)("p",null,"We will not be discussing about running with ZIO again, as it is just the same regardless of what the description is.\nWe will discuss only about how to describe your configuration for the rest of this page."),(0,i.kt)("h2",{id:"built-in-types"},"Built-in types"),(0,i.kt)("p",null,"We have already seen ",(0,i.kt)("inlineCode",{parentName:"p"},'string("TOKEN")')," and ",(0,i.kt)("inlineCode",{parentName:"p"},'int("PORT")')," to fetch string and int types respectively.\nWe support the following:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"string\nboolean\nbyte\nshort\nint\nlong\nbigInt\nfloat\ndouble\nbigDecimal\nuri\nuuid\nlocalDate\nlocalTime\nlocalDateTime\nDuration\ninstant\nfile\nurl\netc\n\n")),(0,i.kt)("p",null,"Complex types include ",(0,i.kt)("inlineCode",{parentName:"p"},"list"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," etc. More details to follow"),(0,i.kt)("h2",{id:"optional-types"},"Optional Types"),(0,i.kt)("p",null,"Say, dburl is an optional type, then it is as simple as"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'string("DB_URL").optional\n')),(0,i.kt)("p",null,"That is,"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'case class MyConfigWithOptionalUrl(ldap: String, port: Port, dburl: Option[String])\n\nval myConfigOptional =\n  (string("LDAP") zip int("PORT").to[Port] zip\n    string("DB_URL").optional).to[MyConfigWithOptionalUrl]\n')),(0,i.kt)("h2",{id:"default"},"Default"),(0,i.kt)("p",null,"Sometimes, we don't need an optional value and instead happy providing a default value."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'val defaultConfig =\n  string("USERNAME").default("ROOT")\n')),(0,i.kt)("p",null,"That is,"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'case class MyConfigWithDefaultUserName(username: String, port: Int)\n\nval myConfigDefault =\n  (string("USERNAME").default("root-oh") zip int("PORT")).to[MyConfigWithDefaultUserName]\n')),(0,i.kt)("p",null,"We can also do things like fully overriding the entire configuration; might be helpful for tests."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'myConfigDefault.default(MyConfigWithDefaultUserName("test", 80))\n')),(0,i.kt)("h2",{id:"new-types"},"New types"),(0,i.kt)("p",null,"We love ",(0,i.kt)("inlineCode",{parentName:"p"},"Port")," instead of ",(0,i.kt)("inlineCode",{parentName:"p"},"Int")," that represents a db port."),(0,i.kt)("p",null,"In this scenario, you could do"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'int("PORT").to[Port]\n')),(0,i.kt)("p",null,"where port is;"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"case class Port(value: Int)\n")),(0,i.kt)("p",null,"That is,"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'case class MyCustomConfig(ldap: String, port: Port, dburl: String)\n\n// Before\n val myConfigWithCustomType =\n   (string("LDAP") zip int("PORT").to[Port] zip\n     string("DB_URL")).to[MyCustomConfig]\n')),(0,i.kt)("h2",{id:"multiple-sources"},"Multiple sources"),(0,i.kt)("p",null,"While it may not be always a good idea having to rely on multiple sources to form the application config,\nzio-config do support this scenario. This can happen in complex applications."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'val source1 = ConfigSource.fromSystemProps()\nval source2 = ConfigSource.fromSystemEnv()\n \nval configDesc =\n  (string("LDAP").from(source1.orElse(source2)) zip int("PORT").to[Port].from(source1) zip\n    string("DB_URL").optional.from(source2)).to[MyConfigWithOptionalUrl]\n\nread(configDesc)\n\n// we can also separately add new config\nread(configDesc from ConfigSource.fromMap(Map.empty))\n\n// In this case, `ConfigSource.fromMap` will also be tried along with the sources that are already given.\n')),(0,i.kt)("p",null,"We can reset the sources for the config using"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"configDesc.unsourced\n")),(0,i.kt)("p",null,"By that way, in tests we could remove the sources from each parameter and ask it to get it\nfrom a constant map for all of it."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'val testConfig =\n  configDesc.unsourced from ConfigSource.fromMap(Map("LDAP" -> "x", "DB_URL" -> "y",  "PORT" -> "1235"))\n')),(0,i.kt)("h2",{id:"combining-various-effectful-sources"},"Combining various effectful sources"),(0,i.kt)("p",null,"There are various ways you can interact with zio-config when dealing with multiple sources.\nBelow given is a naive example, that will help you get a gist of how to get config values from various\nsources, especially when some of the sources returns ZIO."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import java.io.File\n\nimport zio._\nimport zio.config._\nimport zio.config.typesafe._\n\n/**\n * One of the ways you can summon various sources especially\n * when some of the `fromSource` functions return ZIO.\n */\nobject CombineSourcesExample extends ZIOAppDefault {\n  override def run =\n    application.either.flatMap(r => Console.printLine(s"Result: ${r}"))\n\n  case class Config(username: String , password: String)\n\n  val desc: ConfigDescriptor[Config] = {\n    val hoconFile = TypesafeConfigSource.fromHoconFile(new File("/invalid/path"))\n    val constant  = TypesafeConfigSource.fromHoconString(s"")\n    val env       = ConfigSource.fromSystemEnv()\n    val sysProp   = ConfigSource.fromSystemProps()\n    val source    = hoconFile <> constant <> env <> sysProp\n    (descriptor[Config] from source)\n  }\n\n  val application =\n    for {\n      configValue <- read(desc).mapError(_.prettyPrint())\n      string      <- ZIO.fromEither(configValue.toJson(desc))\n      _           <- Console.printLine(string)\n    } yield ()\n}\n')),(0,i.kt)("h2",{id:"either-types-orelseeither"},"Either Types (orElseEither)"),(0,i.kt)("p",null,"For instance, if we are ok accepting either a token or username, then our target type should be ",(0,i.kt)("inlineCode",{parentName:"p"},"Either[String, String]"),"\n.\nIn this case, We can use ",(0,i.kt)("inlineCode",{parentName:"p"},"orElseEither")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"<+>"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'string("USERNAME").orElseEither(string("TOKEN"))\n')),(0,i.kt)("p",null,"That is,"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'case class MyConfigWithEither(usernameOrToken: Either[String, String], port: Int)\n\nval myConfigEither =\n  (string("USERNAME").orElseEither(string("TOKEN")) zip int("PORT")).to[MyConfigWithEither]\n\n')),(0,i.kt)("p",null,"We can also use ",(0,i.kt)("inlineCode",{parentName:"p"},"<+>")," combinator."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'string("USERNAME") <+> (string("TOKEN"))\n')),(0,i.kt)("p",null,"We can apply the ",(0,i.kt)("inlineCode",{parentName:"p"},"Either")," logic at a much more global level, as in, give me either a ",(0,i.kt)("inlineCode",{parentName:"p"},"Prod")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"Test")," config."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'case class Dev(userName: String, password: String)\ncase class Prod(token: String, code: Int)\n\ntype ZConfig = Either[Prod, Dev]\n\nval dev = (string("USERNAME") zip string("PASSWORD")).to[Dev]\nval prod = (string("TOKEN") zip int("CODE")).to[Prod]\n\nprod <+> dev // that represents a description returning Config\n// ConfigDescriptor[ Config]\n\n')),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"orElseEither")," works with complex hocon sources, which is an additional benefit compared to existing configuration\nlibraries.\nYou can also choose to avoid a ",(0,i.kt)("inlineCode",{parentName:"p"},"sealed trait")," encoding if all we need is ",(0,i.kt)("inlineCode",{parentName:"p"},"Either[Int, String]"),", for instance."),(0,i.kt)("h2",{id:"orelse"},"OrElse"),(0,i.kt)("p",null,'Sometimes, we can try two different values and pick one. That means, the target is "NOT" ',(0,i.kt)("inlineCode",{parentName:"p"},"Either")," but any raw type.\nIn this scenario, We can use ",(0,i.kt)("inlineCode",{parentName:"p"},"orElse")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"<>")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'string("TOKEN") orElse string("token")\n')),(0,i.kt)("p",null,"Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'val configOrElse =\n  (string("TOKEN").orElse(string("token_x")) zip int("CODE")).to[Prod]\n')),(0,i.kt)("p",null,'It tries to fetch the value corresponding to "TOKEN", and if it fails, it tries "token_x" and returns the corresponding\nvalue.'),(0,i.kt)("p",null,"We can also use ",(0,i.kt)("inlineCode",{parentName:"p"},"<>")," combinator."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'string("TOKEN") <> string("token") <> string("TOKEN_INFO")\n')),(0,i.kt)("h2",{id:"composing-multiple-configurations"},"Composing multiple configurations"),(0,i.kt)("p",null,"This is more of a real life scenario, where you can different micro configurations for readability and maintainability."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'case class Database(url: String, port: Int)\ncase class AwsConfig(c1: Database, c3: String)\n\nval databaseConfig =\n  (string("connection") zip int("port")).to[Database]\n\n(databaseConfig zip string("c3")).to[AwsConfig]\n')),(0,i.kt)("h2",{id:"nesting"},"Nesting"),(0,i.kt)("p",null,"In addition to the primitive types, zio-config provides a combinator for nesting a configuration within another."),(0,i.kt)("p",null,"This might not feel intuitive at first, however, zio-config is designed to easily adapt to\nany other configuration parsing libraries that deal with file formats such as HOCON that natively support nested\nconfigurations."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'case class AwsConfigExtended(c1: Database, c2: Database, c3: String)\n\nval appConfig =\n  (nested("south") { databaseConfig } zip\n    nested("east") { databaseConfig } zip\n    string("appName")).to[AwsConfigExtended]\n\n// Let\'s say, a nested configuration as a flattened map is just "." delimited keys in a flat map.\nval constantMap =\n  Map(\n    "south.connection" -> "abc.com",\n    "east.connection"  -> "xyz.com",\n    "east.port"        -> "8888",\n    "south.port"       -> "8111",\n    "appName"          -> "myApp"\n  )\n\nZConfig.fromMap(constantMap, appConfig)\n')),(0,i.kt)("p",null,"Note that, you can write this back as well. This is discussed in write section"),(0,i.kt)("h2",{id:"collectall-sequence"},"CollectAll (Sequence)"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'def database(i: Int) =\n  (string(s"${i}_URL") zip int(s"${i}_PORT")).to[Database]\n\nval list: ConfigDescriptor[List[Database]] =\n  collectAll(database(0), (1 to 10).map(database): _*)\n')),(0,i.kt)("p",null,"Running this to ZIO will result in non empty list of database"),(0,i.kt)("p",null,"NOTE: ",(0,i.kt)("inlineCode",{parentName:"p"},"collectAll")," is a synonym for ",(0,i.kt)("inlineCode",{parentName:"p"},"sequence"),"."),(0,i.kt)("h2",{id:"handling-list-is-just-easy"},"Handling list is just easy!"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'final case class PgmConfig(a: String, b: List[String])\n\nval configWithList =\n  (string("xyz") zip list("regions")(string)).to[PgmConfig]\n\nConfig.fromEnv(configWithList, valueDelimiter = Some(","))\n// or read(configWithList from ConfigSource.fromEnv(valueDelimiter = Some(",")))\n')),(0,i.kt)("p",null,"List is probably better represented in HOCON files.\nzio-config-typesafe enables you to depend on HOCON files to manage your configuration."),(0,i.kt)("p",null,"Given;"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'val listHocon =\n  """\n    accounts = [\n      {\n         region : us-east\n         accountId: jon\n      }\n      {\n         region : us-west\n         accountId: chris\n      }\n    ]\n    database {\n        port : 100\n        url  : postgres\n    }\n  """\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.config.typesafe.TypesafeConfigSource._\nimport zio.config.magnolia._\n\n// A nested example with type safe config, and usage of magnolia\nfinal case class Accnt(region: String, accountId: String)\n\nfinal case class Db(port: Int, url: String)\n\nfinal case class AwsDetails(accounts: List[Accnt], database: Db)\n\nval autoListConfig = descriptor[AwsDetails]\n\nread(autoListConfig from hocon(listHocon))\n\n// yields\n//  AwsDetails(\n//    List(Accnt("us-east", "jon"), Accnt("us-west", "chris")),\n//    Db(100, "postgres")\n//  )\n')),(0,i.kt)("p",null,"Note that ",(0,i.kt)("inlineCode",{parentName:"p"},"autoListConfig")," (automatically generated) config, is exactly similar to:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'val accnt =\n  (string("region") zip string("accountId")).to[Accnt]\n\nval db = (int("port") zip string("url")).to[Db]\n\nval nonAutomatic =\n  (nested("accounts")(list(accnt)) zip nested("database")(db)).to[AwsDetails]\n')),(0,i.kt)("p",null,"Please find more details on the behaviour of ",(0,i.kt)("inlineCode",{parentName:"p"},"List")," for various sources in ",(0,i.kt)("inlineCode",{parentName:"p"},"Sources")," section of the documentation."))}u.isMDXComponent=!0}}]);