"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[1479],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>g});var a=t(67294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var l=a.createContext({}),c=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},p=function(e){var n=c(e.components);return a.createElement(l.Provider,{value:n},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=c(t),m=i,g=u["".concat(l,".").concat(m)]||u[m]||d[m]||o;return t?a.createElement(g,r(r({ref:n},p),{},{components:t})):a.createElement(g,r({ref:n},p))}));function g(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,r=new Array(o);r[0]=m;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[u]="string"==typeof e?e:i,r[1]=s;for(var c=2;c<o;c++)r[c]=t[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},43325:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var a=t(87462),i=(t(67294),t(3905));const o={id:"automatic-derivation-of-config-descriptor",title:"Automatic Derivation of ConfigDescriptor"},r=void 0,s={unversionedId:"zio-config/automatic-derivation-of-config-descriptor",id:"zio-config/automatic-derivation-of-config-descriptor",title:"Automatic Derivation of ConfigDescriptor",description:"By bringing in zio-config-magnolia we  avoid all the boilerplate required to define the config. With a single import, ConfigDescriptor is automatically derived.",source:"@site/docs/zio-config/automatic-derivation-of-config-descriptor.md",sourceDirName:"zio-config",slug:"/zio-config/automatic-derivation-of-config-descriptor",permalink:"/zio-config/automatic-derivation-of-config-descriptor",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/zio-config/automatic-derivation-of-config-descriptor.md",tags:[],version:"current",frontMatter:{id:"automatic-derivation-of-config-descriptor",title:"Automatic Derivation of ConfigDescriptor"},sidebar:"ecosystem-sidebar",previous:{title:"Manual creation of ConfigDescriptor",permalink:"/zio-config/manual-creation-of-config-descriptor"},next:{title:"Read from various Sources",permalink:"/zio-config/read-from-various-sources"}},l={},c=[{value:"Example",id:"example",level:3},{value:"Config",id:"config",level:4},{value:"AutoDerivation",id:"autoderivation",level:4},{value:"Documentation while automatic derivation",id:"documentation-while-automatic-derivation",level:3},{value:"Custom ConfigDescription",id:"custom-configdescription",level:3},{value:"Is that the only way for custom derivation ?",id:"is-that-the-only-way-for-custom-derivation-",level:3},{value:"Please give descriptions wherever possible for a better experience",id:"please-give-descriptions-wherever-possible-for-a-better-experience",level:3},{value:"Where to place these implicits ?",id:"where-to-place-these-implicits-",level:3},{value:"Change Keys (CamelCase, kebab-case etc)",id:"change-keys-camelcase-kebab-case-etc",level:3},{value:"Scala3 Autoderivation",id:"scala3-autoderivation",level:2},{value:"No support for <code>AnyVal</code>",id:"no-support-for-anyval",level:3},{value:"Example:",id:"example-1",level:4},{value:"Example:",id:"example-2",level:4},{value:"No guaranteed behavior for scala-3 enum yet",id:"no-guaranteed-behavior-for-scala-3-enum-yet",level:3},{value:"No support for recursive config in auto-derivation, but we can make it work",id:"no-support-for-recursive-config-in-auto-derivation-but-we-can-make-it-work",level:3},{value:"Custom Keys",id:"custom-keys",level:3},{value:"Inbuilt support for pure-config",id:"inbuilt-support-for-pure-config",level:2},{value:"Allow concise config source strings",id:"allow-concise-config-source-strings",level:2},{value:"Your ConfigSource is exactly your product and coproduct",id:"your-configsource-is-exactly-your-product-and-coproduct",level:2},{value:"Example:",id:"example-3",level:3}],p={toc:c},u="wrapper";function d(e){let{components:n,...t}=e;return(0,i.kt)(u,(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"By bringing in ",(0,i.kt)("inlineCode",{parentName:"p"},"zio-config-magnolia")," we  avoid all the boilerplate required to define the config. With a single import, ",(0,i.kt)("inlineCode",{parentName:"p"},"ConfigDescriptor")," is automatically derived."),(0,i.kt)("p",null,"Also, we will get to see the Hocon config for coproducts is devoid of any extra tagging to satisfy the library. This is much easier/intuitive unlike many existing implementations."),(0,i.kt)("p",null,"Take a look at the magnolia examples in ",(0,i.kt)("inlineCode",{parentName:"p"},"zio-config"),". One of them is provided here for quick access."),(0,i.kt)("p",null,"Note:  ",(0,i.kt)("inlineCode",{parentName:"p"},"zio-config-shapeless")," is an alternative to ",(0,i.kt)("inlineCode",{parentName:"p"},"zio-config-magnolia")," to support scala 2.11 projects. It will be deprecated once we find users have moved on from scala 2.11. "),(0,i.kt)("p",null,"Also, there are a few differences when it comes to scala-3 for auto-matic derivation.\nRefer scala-3 section in this page for specific differences. Most of them, is an intentional reduction in the number of moving parts in the entire mechanism of auto-derivation, plus, a few subtle limitations."),(0,i.kt)("h3",{id:"example"},"Example"),(0,i.kt)("h4",{id:"config"},"Config"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"sealed trait X\n\nobject X {\n  case object A extends X\n  case object B extends X\n  case object C extends X\n  case class  DetailsWrapped(detail: Detail) extends X\n  \n  case class Detail(firstName: String, lastName: String, region: Region)\n  case class Region(suburb: String, city: String)\n}\n\n/**\n * We use automatic derivation here.\n * As an example, In order to specify, {{{ x = a }}} in the source where `a`\n * represents X.A object, we need a case class that wraps\n * the sealed trait, and we use the field name of this case class as the key\n */\ncase class MyConfig(x: X)\n")),(0,i.kt)("h4",{id:"autoderivation"},"AutoDerivation"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"// Setting up imports\n\nimport zio.config._, zio.config.typesafe._\n  import zio.config.magnolia._\n\n  import X._\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'// Defining different possibility of HOCON source\n\nval aHoconSource =\n  ConfigSource\n    .fromHoconString("x = A")\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'val bHoconSource =\n  ConfigSource\n    .fromHoconString("x = B")\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'val cHoconSource =\n  ConfigSource\n    .fromHoconString("x = C")\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'val dHoconSource =\n  ConfigSource\n    .fromHoconString(\n      s"""\n         | x {\n         |   DetailsWrapped {\n         |    detail  {\n         |      firstName : ff\n         |      lastName  : ll\n         |      region {\n         |        city   : syd\n         |        suburb : strath\n         |     }\n         |   }\n         |  }\n         |}\n         |""".stripMargin\n    )\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'// Let\'s try automatic derivation\n\nread(descriptor[MyConfig] from aHoconSource)\n// res0: Right(MyConfig(A))\n\nread(descriptor[MyConfig] from bHoconSource)\n// res0: Right(MyConfig(B))\n\nread(descriptor[MyConfig] from cHoconSource)\n// res0: Right(MyConfig(C))\n\nread(descriptor[MyConfig] from dHoconSource)\n// res0: Right(MyConfig(DetailsWrapped(Detail("ff", "ll", Region("strath", "syd")))))\n')),(0,i.kt)("p",null,"To know more about various semantics of ",(0,i.kt)("inlineCode",{parentName:"p"},"descriptor"),", please refer to the ",(0,i.kt)("a",{parentName:"p",href:"https://javadoc.io/static/dev.zio/zio-config-magnolia_2.13/1.0.0-RC31-1/zio/config/magnolia/index.html#descriptor%5BA%5D(implicitconfig:zio.config.magnolia.package.Descriptor%5BA%5D):zio.config.ConfigDescriptor%5BA%5D"},"api docs"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"NOTE")),(0,i.kt)("p",null,"The fieldNames and classnames remain the same as that of case-classes and sealed-traits."),(0,i.kt)("p",null,"If you want custom names for your fields, use ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," annotation."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'import zio.config.derivation.name\n\n@name("detailsWrapped")\ncase class  DetailsWrapped(detail: Detail) extends X\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import zio.config._\n\ndescriptor[MyConfig].mapKey(toKebabCase)\n")),(0,i.kt)("p",null,"With the above change",(0,i.kt)("inlineCode",{parentName:"p"},"firstName")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"lastName")," in the above HOCON example can be ",(0,i.kt)("inlineCode",{parentName:"p"},"first-name")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"last-name"),"\nrespectively."),(0,i.kt)("p",null,"There are various ways in which you can customise the derivation of sealed traits.\nThis is a bit involving, and more documentations will be provided soon."),(0,i.kt)("h3",{id:"documentation-while-automatic-derivation"},"Documentation while automatic derivation"),(0,i.kt)("p",null,"With ",(0,i.kt)("inlineCode",{parentName:"p"},"describe")," annotation you can still document your config while automatically generating the config"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.config.magnolia.describe\n\n@describe("This config is about aws")\ncase class Aws(region: String, dburl: DbUrl)\ncase class DbUrl(value: String)\n')),(0,i.kt)("p",null,"This will be equivalent to the manual configuration of:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'(string("region") zip string("dburl").transform(DbUrl, _.value)).to[Aws] ?? "This config is about aws"\n')),(0,i.kt)("p",null,"You could provide ",(0,i.kt)("inlineCode",{parentName:"p"},"describe")," annotation at field level"),(0,i.kt)("p",null,"Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'case class Aws(@describe("AWS region") region: String, dburl: DbUrl)\n')),(0,i.kt)("p",null,"This will be equivalent to the manual configuration of:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'(string("region") ?? "AWS region" zip string("dburl").to[DbUrl]).to[Aws] ?? "This config is about aws"\n')),(0,i.kt)("h3",{id:"custom-configdescription"},"Custom ConfigDescription"),(0,i.kt)("p",null,"Every field in a case class should have an instance of ",(0,i.kt)("inlineCode",{parentName:"p"},"Descriptor")," in order for the automatic derivation to work.\nThis doesn't mean the entire design of zio-config is typeclass based. For the same reason, the typeclass\n",(0,i.kt)("inlineCode",{parentName:"p"},"Descriptor")," exists only in zio-config-magnolia (or zio-config-shapeless) package."),(0,i.kt)("p",null,"As an example, given below is a case class where automatic derivation won't work, and result in a compile time error:\nAssume that, ",(0,i.kt)("inlineCode",{parentName:"p"},"AwsRegion")," is a type that comes from AWS SDK."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"import java.time.ZonedDateTime\n\ncase class Execution(time: AwsRegion, id: Int)\n")),(0,i.kt)("p",null,"In this case, ",(0,i.kt)("inlineCode",{parentName:"p"},"descriptor[Execution]")," will give us the following descriptive compile error."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"magnolia: could not find Descriptor.Typeclass for type <outside.library.package>.AwsRegion\n  in parameter 'time' of product type <your.packagename>.Execution\n")),(0,i.kt)("p",null,"This is because zio-config-magnolia failed to derive an instance of Descriptor for AwsRegion."),(0,i.kt)("p",null,"In order to provide implicit instances, following choices are there"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"import zio.config.magnolia.{Descriptor, descriptor}\n\nimplicit val awsRegionDescriptor: Descriptor[Aws.Region] =\n  Descriptor[String].transform(string => AwsRegion.from(string), _.toString)\n\n")),(0,i.kt)("p",null,"Now ",(0,i.kt)("inlineCode",{parentName:"p"},"descriptor[Execution]")," compiles."),(0,i.kt)("p",null,"Custom descriptors are also needed in case you use value classes to describe your configuration. You can use them\ntogether with automatic derivation and those implicit custom descriptors will be taken automatically into account"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import zio.config.magnolia.{descriptor, Descriptor}\n\nfinal case class AwsRegion(value: String) extends AnyVal {\n  override def toString: String = value\n}\n\nobject AwsRegion {\n  implicit val descriptor: Descriptor[AwsRegion] = \n    Descriptor[String].transform(AwsRegion(_), _.value)\n}\n")),(0,i.kt)("h3",{id:"is-that-the-only-way-for-custom-derivation-"},"Is that the only way for custom derivation ?"),(0,i.kt)("p",null,"What if our custom type is complex enough that, parsing from a string would actually fail? The answer is, zio-config provides with all the functions that you need to handle errors."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"mport zio.config.magnolia.{Descriptor, descriptor}\n\nimplicit val descriptorO: Descriptor[ZonedDateTime] =\n  Descriptor[String].transformOrFailLeft(x => Try (ZonedDateTime.parse(x)).toEither.swap.map(_.getMessage).swap)(_.toString)\n")),(0,i.kt)("p",null,"What is transformOrFailLeft ? Parsing a String to ZonedDateTime can fail, but converting it back to a string\nwon't fail. Logically, these are respectively the first 2 functions that we passed to transformEitherLeft. "),(0,i.kt)("p",null,"PS: We recommend not to use ",(0,i.kt)("inlineCode",{parentName:"p"},"throwable.getMessage"),". Provide more descriptive error message."),(0,i.kt)("p",null,"You can also rely on ",(0,i.kt)("inlineCode",{parentName:"p"},"transformOrfail")," if both ",(0,i.kt)("inlineCode",{parentName:"p"},"to")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"fro")," can fail. "),(0,i.kt)("h3",{id:"please-give-descriptions-wherever-possible-for-a-better-experience"},"Please give descriptions wherever possible for a better experience"),(0,i.kt)("p",null,"Giving descriptions is going to be helpful. While all the built-in types have documentations, it is better we give\nsome description to custom types as well. For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'mport zio.config.magnolia.{Descriptor, descriptor}\n\n\nimplicit val awsRegionDescriptor: Descriptor[Aws.Region] =\n  Descriptor[String].transform(string => AwsRegion.from(string), _.toString) ?? "value of type AWS.Region"\n')),(0,i.kt)("p",null,"This way, when there is an error due to MissingValue, we get an error message (don't forget to use prettyPrint)\nthat describes about the config parameter. For example, see the ",(0,i.kt)("inlineCode",{parentName:"p"},"Details")," corresponding to the first ",(0,i.kt)("inlineCode",{parentName:"p"},"MissingValue")," in a sample error message below."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"}," ReadError:\n \u2565\n \u2560\u2500MissingValue\n \u2551 path: aws.region\n \u2551 Details: value of type AWS.Region\n \u2551\n \u2560\u2500FormatError\n \u2551 cause: Provided value is 3dollars, expecting the type double\n \u2551 path: cost\n \u25bc\n")),(0,i.kt)("h3",{id:"where-to-place-these-implicits-"},"Where to place these implicits ?"),(0,i.kt)("p",null,"If the types are owned by us, then the best place to keep implicit instance is the companion object of that type."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'final case clas MyAwsRegion(value: AwsRegion)\n\nobject MyAwsRegion {\n  implicit val awsRegionDescriptor: Descriptor[MyAwsRegion] =\n    Descriptor[String]\n      .transform(\n        string => MyAwsRegion(AwsRegion.from(string)), \n        _.value.toString\n      ) ?? "value of type AWS.Region"\n}\n')),(0,i.kt)("p",null,"However, sometimes, the types are owned by an external library."),(0,i.kt)("p",null,"In these situations, better off place the implicit closer to where we call the automatic derivation.\nPlease find the example in ",(0,i.kt)("inlineCode",{parentName:"p"},"magnolia")," package in examples module."),(0,i.kt)("h3",{id:"change-keys-camelcase-kebab-case-etc"},"Change Keys (CamelCase, kebab-case etc)"),(0,i.kt)("p",null,"Please find the examples in ChangeKeys.scala in magnolia module to find how to manipulate keys in an automatic derivation such as being able to specify keys as camelCase, kebabCase or snakeCase in the source config."),(0,i.kt)("h2",{id:"scala3-autoderivation"},"Scala3 Autoderivation"),(0,i.kt)("p",null,"Works just like scala-2.12 and scala-2.13.\nIf possible, we will make this behaviour consistent in scala-2.12 and scala-2.13 in future versions of zio-config."),(0,i.kt)("h3",{id:"no-support-for-anyval"},"No support for ",(0,i.kt)("inlineCode",{parentName:"h3"},"AnyVal")),(0,i.kt)("p",null,"You may encounter the following error, if you have ",(0,i.kt)("inlineCode",{parentName:"p"},"AnyVal")," in your config."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"no implicit argument of type zio.config.magnolia.Descriptor\n")),(0,i.kt)("p",null,"If looking for new-types, use better strategies than AnyVal (",(0,i.kt)("a",{parentName:"p",href:"https://afsal-taj06.medium.com/newtype-is-new-now-63f1b632429d"},"https://afsal-taj06.medium.com/newtype-is-new-now-63f1b632429d"),"), and add custom ",(0,i.kt)("inlineCode",{parentName:"p"},"Descriptor")," explicitly in its companion objects."),(0,i.kt)("p",null,"We will consider adding ",(0,i.kt)("inlineCode",{parentName:"p"},"AnyVal")," support, for supporting legacy applications in future versions of zio-config."),(0,i.kt)("p",null,"In the meantime, if you are migrating from Scala 2 where you had custom descriptors defined for value classes you need to slightly change your code to compile it with Scala 3"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"remove ",(0,i.kt)("inlineCode",{parentName:"li"},"AnyVal")," trait"),(0,i.kt)("li",{parentName:"ul"},"modify definition of custom descriptor"),(0,i.kt)("li",{parentName:"ul"},"add import to include ",(0,i.kt)("inlineCode",{parentName:"li"},"ConfigDescriptor")," combinators")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import zio.config.ConfigDescriptor._\nimport zio.config.magnolia.{descriptor, Descriptor}\n\nfinal case class AwsRegion(value: String) {\n  override def toString: String = value\n}\n\nobject AwsRegion {\n  given Descriptor[AwsRegion] =\n    Descriptor.from(string.to[AwsRegion])\n}\n")),(0,i.kt)("p",null,"this way there is no need for you to update the configuration files."),(0,i.kt)("h4",{id:"example-1"},"Example:"),(0,i.kt)("p",null,"The name of the sealed trait itself is skipped completely by default.\nHowever, if you put a ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," annotation on top of the sealed-trait itself,\nthen it becomes part of the config. "),(0,i.kt)("p",null,"The name of the case-class should be available in config-source,\nand by default it should the same name as that of the case-class."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"sealed trait A\ncase class B(x: String) extends A\ncase class C(y: String) extends A\n\ncase class Config(a: A) \n")),(0,i.kt)("p",null,"With the above config, ",(0,i.kt)("inlineCode",{parentName:"p"},"descriptor[A]")," can read following source."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'{\n  "a" : {\n   "B" : {\n      "x" : "abc"\n     }\n   }\n  }\n}\n\n// or a.B.x="abc", if your source is just property file\n')),(0,i.kt)("p",null,"However, if you give ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," annotation for A, the name of the sealed trait\nshould be part of the config too. This is rarely used."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'@name("aaaaa")\nsealed trait A\ncase class B(x: String) extends A\ncase class C(y: String) extends A\n\ncase class Config(a: A) \n')),(0,i.kt)("p",null,"With the above config, ",(0,i.kt)("inlineCode",{parentName:"p"},"descriptor[A]")," can read following source."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'{\n  "a" : {\n    "aaaaa" : \n      "B" : {\n        "x" : "abc"\n     }\n   }\n  }\n}\n')),(0,i.kt)("p",null,"Similar to scala-2.x, you can give name annotations to any case-class as well (similar to scala 2.x)"),(0,i.kt)("h4",{id:"example-2"},"Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'sealed trait A\n\n@name("b")\ncase class B(x: String) extends A\ncase class C(y: String) extends A\n\ncase class Config(a: A) \n')),(0,i.kt)("p",null,"In this case, the config should be"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'{\n  "a" : {\n   "b" : {\n      "x" : "abc"\n     }\n   }\n  }\n}\n')),(0,i.kt)("h3",{id:"no-guaranteed-behavior-for-scala-3-enum-yet"},"No guaranteed behavior for scala-3 enum yet"),(0,i.kt)("p",null,"With the current release, there is no guaranteed support of scala-3 enum.\nUse ",(0,i.kt)("inlineCode",{parentName:"p"},"sealed trait")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"case class")," pattern."),(0,i.kt)("h3",{id:"no-support-for-recursive-config-in-auto-derivation-but-we-can-make-it-work"},"No support for recursive config in auto-derivation, but we can make it work"),(0,i.kt)("p",null,"There is no support for auto-deriving recursive config with scala-3.\nPlease refer to examples in magnolia package (not in the main examples module)"),(0,i.kt)("h3",{id:"custom-keys"},"Custom Keys"),(0,i.kt)("p",null,"With zio-config-3.x, the only way to change keys is as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"// mapKey is just a function in `ConfigDescriptor` that pre-existed\n\nval config = descriptor[Config].mapKey(_.toUpperCase)\n")),(0,i.kt)("p",null,"instead of "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"// No longer supported\nval customDerivation = new DeriveConfigDescriptor {\n  override def mapFieldName(key: String) = key.toUpperCase\n }\n\nimport customDerivation._\n\nval config = descriptor[Config]\n")),(0,i.kt)("h2",{id:"inbuilt-support-for-pure-config"},"Inbuilt support for pure-config"),(0,i.kt)("p",null,"Many users make use of the label ",(0,i.kt)("inlineCode",{parentName:"p"},"type")," in HOCON files to annotate the type of the coproduct. Now on, zio-config has inbuilt support for reading such a file/string using ",(0,i.kt)("inlineCode",{parentName:"p"},"descriptorForPureConfig"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'mport zio.config._, typesafe._, magnolia._\n\nsealed trait X\ncase class A(name: String) extends X\ncase class B(age: Int) extends X\n\ncase class AppConfig(x: X)\n\nval str =\n  s"""\n   x : {\n     type = A\n     name = jon\n   }\n  """\n\nread(descriptorForPureConfig[AppConfig] from ConfigSource.fromHoconString(str))\n')),(0,i.kt)("h2",{id:"allow-concise-config-source-strings"},"Allow concise config source strings"),(0,i.kt)("p",null,"With this release we have ",(0,i.kt)("inlineCode",{parentName:"p"},"descriptorWithoutClassNames")," along with ",(0,i.kt)("inlineCode",{parentName:"p"},"descriptor")," that just completely discards the name of the sealed-trait and sub-class (case-class) names, allowing your source less verbose. Note that unlike ",(0,i.kt)("inlineCode",{parentName:"p"},"pure-config")," example above, we don't need to have an extra label ",(0,i.kt)("inlineCode",{parentName:"p"},"type : A"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'sealed trait Y\n\nobject Y {\n  case class A(age: Int)     extends Y\n  case class B(name: String) extends Y\n}\n\ncase class AppConfig(x: Y)\n\nval str =\n       s"""\n           x : {\n             age : 10\n           }\n          """\n\nread(descriptorWithoutClassNames[AppConfig] from ConfigSource.fromHoconString(str))\n')),(0,i.kt)("p",null,"PS: If you are using ",(0,i.kt)("inlineCode",{parentName:"p"},"descriptor")," instead of ",(0,i.kt)("inlineCode",{parentName:"p"},"descriptorWithoutClassNames"),", then the source has to be:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"x : {\n  A : { \n      age : 10\n  }\n}\n")),(0,i.kt)("h2",{id:"your-configsource-is-exactly-your-product-and-coproduct"},"Your ConfigSource is exactly your product and coproduct"),(0,i.kt)("p",null,"Some users prefer to encode the config-source exactly the same as that of Scala class files. The implication is, the source will know the name of the ",(0,i.kt)("inlineCode",{parentName:"p"},"sealed trait")," and the name of all of its ",(0,i.kt)("inlineCode",{parentName:"p"},"subclasses"),". There are several advantages to such an approach, while it can be questionable in certain situations. Regardless, zio-config now has inbuilt support to have this pattern."),(0,i.kt)("h3",{id:"example-3"},"Example:"),(0,i.kt)("p",null,"Say, the config ADT is as below:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"sealed trait Y\n\nobject Y {\n  case class A(age: Int)     extends Y\n  case class B(name: String) extends Y\n}\n\ncase class AppConfig(x: X)\n")),(0,i.kt)("p",null,"Then the corresponding config-source should be as follows. Keep a note that under ",(0,i.kt)("inlineCode",{parentName:"p"},"x"),", the name of sealed trait ",(0,i.kt)("inlineCode",{parentName:"p"},"Y")," also exist."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'val str =\n  s"""\n     x : {\n           Y : {\n              A : {\n                age : 10\n              }\n         }\n     }\n    """\n')),(0,i.kt)("p",null,"To read such a string (or any config-source encoded in such a hierarchy), use ",(0,i.kt)("inlineCode",{parentName:"p"},"descriptorWithClassNames")," instead of ",(0,i.kt)("inlineCode",{parentName:"p"},"descriptor"),". In short, ",(0,i.kt)("inlineCode",{parentName:"p"},"descriptorWithClassNames")," considers the name of sealed-trait."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"read(descriptorWithClassNames[AppConfig] from ConfigSource.fromHoconString(str))\n")))}d.isMDXComponent=!0}}]);