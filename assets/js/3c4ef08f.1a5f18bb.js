"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[32692],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>f});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},l=Object.keys(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),d=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=d(e.components);return r.createElement(s.Provider,{value:t},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,l=e.originalType,s=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),c=d(n),m=a,f=c["".concat(s,".").concat(m)]||c[m]||u[m]||l;return n?r.createElement(f,o(o({ref:t},p),{},{components:n})):r.createElement(f,o({ref:t},p))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var l=n.length,o=new Array(l);o[0]=m;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i[c]="string"==typeof e?e:a,o[1]=i;for(var d=2;d<l;d++)o[d]=n[d];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},82414:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>c,frontMatter:()=>l,metadata:()=>i,toc:()=>d});var r=n(87462),a=(n(67294),n(3905));const l={id:"index",title:"Introduction to ZIO SQL",sidebar_label:"ZIO SQL"},o=void 0,i={unversionedId:"zio-sql/index",id:"zio-sql/index",title:"Introduction to ZIO SQL",description:"Installation",source:"@site/docs/zio-sql/index.md",sourceDirName:"zio-sql",slug:"/zio-sql/",permalink:"/zio-sql/",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/zio-sql/index.md",tags:[],version:"current",frontMatter:{id:"index",title:"Introduction to ZIO SQL",sidebar_label:"ZIO SQL"},sidebar:"ecosystem-sidebar",previous:{title:"ZIO SBT",permalink:"/zio-sbt/"},next:{title:"Deep dive",permalink:"/zio-sql/deep-dive"}},s={},d=[{value:"Installation",id:"installation",level:2},{value:"Imports and modules",id:"imports-and-modules",level:2},{value:"Table schema",id:"table-schema",level:2},{value:"Table schema decomposition",id:"table-schema-decomposition",level:2},{value:"Selects",id:"selects",level:2},{value:"Inserts",id:"inserts",level:2},{value:"Updates",id:"updates",level:2},{value:"Deletes",id:"deletes",level:2},{value:"Transactions",id:"transactions",level:2},{value:"Printing queries",id:"printing-queries",level:2},{value:"Running queries",id:"running-queries",level:2}],p={toc:d};function c(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"installation"},"Installation"),(0,a.kt)("p",null,"ZIO SQL is packaged into separate modules for different databases. Depending on which of these (currently supported) systems you're using, you will need to add one of the following dependencies:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'//PostgreSQL\nlibraryDependencies += "dev.zio" %% "zio-sql-postgres" % "0.1.1" \n\n//MySQL\nlibraryDependencies += "dev.zio" %% "zio-sql-mysql" % "0.1.1"\n\n//Oracle\nlibraryDependencies += "dev.zio" %% "zio-sql-oracle" % "0.1.1"\n\n//SQL Server\nlibraryDependencies += "dev.zio" %% "zio-sql-sqlserver" % "0.1.1"\n')),(0,a.kt)("h2",{id:"imports-and-modules"},"Imports and modules"),(0,a.kt)("p",null,"Most of the needed imports will be resolved with"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"import zio.sql._\n")),(0,a.kt)("p",null,"ZIO SQL relies heavily on path dependent types, so to use most of the features you need to be in the scope of one of the database modules:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"trait MyRepositoryModule extends PostgresModule {\n\n  // your ZIO SQL code here\n\n}\n\n// other available modules are MysqlModule, OracleModule and SqlServerModule\n")),(0,a.kt)("p",null,"We will assume this scope in the following examples."),(0,a.kt)("h2",{id:"table-schema"},"Table schema"),(0,a.kt)("p",null,"In order to construct correct and type-safe queries, we need to describe tables by writing user defined data type - case class in which\nname of the case class represents table name, field names represent column names and field types represent column types."),(0,a.kt)("p",null,"Values that will represent tables in DSL are then created by calling ",(0,a.kt)("inlineCode",{parentName:"p"},"defineTable")," method which takes case class type parameter.\nIn order for ",(0,a.kt)("inlineCode",{parentName:"p"},"defineTable")," to work, user need to provide implicit ",(0,a.kt)("inlineCode",{parentName:"p"},"Schema")," of data type."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"import java.util.UUID\nimport zio.sql.postgresql.PostgresJdbcModule\nimport java.time._\n\nobject Repository extends PostgresJdbcModule {\n  final case class Product(id: UUID, name: String, price: BigDecimal)\n  implicit val productSchema = DeriveSchema.gen[Product]\n\n  val products = defineTableSmart[Product]\n  \n  final case class Order(id: UUID, productId: UUID, quantity: Int, orderDate: LocalDate)\n  implicit val orderSchema = DeriveSchema.gen[Order]\n  \n  val orders = defineTable[Order]\n}\n")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"defineTable")," method is overloaded with an alternative that takes table name as an input. User can also specify table name using ",(0,a.kt)("inlineCode",{parentName:"p"},"@name")," annotation.\nAlternatively user can use ",(0,a.kt)("inlineCode",{parentName:"p"},"defineTableSmart")," method which will smartly pluralize table name according to english grammar.\n",(0,a.kt)("inlineCode",{parentName:"p"},"OrderOrigin")," -> ",(0,a.kt)("inlineCode",{parentName:"p"},"order_origins"),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"Foot")," -> ",(0,a.kt)("inlineCode",{parentName:"p"},"feet"),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"PersonAddress")," -> ",(0,a.kt)("inlineCode",{parentName:"p"},"person_addresses"),"\nField names are also converted to lowercase and snake case.\n",(0,a.kt)("inlineCode",{parentName:"p"},"productId")," -> ",(0,a.kt)("inlineCode",{parentName:"p"},"product_id")," and so on."),(0,a.kt)("h2",{id:"table-schema-decomposition"},"Table schema decomposition"),(0,a.kt)("p",null,"Once we have our table definition we need to decompose table into columns which we will use in queries.\nUsing the previous example with ",(0,a.kt)("inlineCode",{parentName:"p"},"Product")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"Order")," table"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"val (id, name, price) = products.columns\n\nval (orderId, productId, quantity) = orders.columns\n")),(0,a.kt)("h2",{id:"selects"},"Selects"),(0,a.kt)("p",null,"Simple select."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"val allProducts = select(productId, name, price).from(products)\n")),(0,a.kt)("p",null,"Using ",(0,a.kt)("inlineCode",{parentName:"p"},"where")," clause."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"def productById(id: UUID) = \n  select(productId, name, price).from(products).where(productId === id)\n")),(0,a.kt)("p",null,"Inner join."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"val ordersWithProductNames = \n  select(orderId, name).from(products.join(orders).on(productId === fkProductId))\n")),(0,a.kt)("p",null,"Left outer join."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"val leftOuter = \n  select(orderId, name).from(products.leftOuter(orders).on(productId === fkProductId))\n")),(0,a.kt)("p",null,"Right outer join."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"val rightOuter = \n  select(orderId, name).from(products.rightOuter(orders).on(productId === fkProductId))\n")),(0,a.kt)("p",null,"Using ",(0,a.kt)("inlineCode",{parentName:"p"},"limit")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"offset")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"val limitedResults = \n  select(orderId, name)\n    .from(products.join(orders)\n    .on(productId === fkProductId))\n    .limit(5)\n    .offset(10)\n")),(0,a.kt)("h2",{id:"inserts"},"Inserts"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'insertInto(products)\n    (productId, name, price)\n  .values((UUID.randomUUID(), "Zionomicon", 10.5))\n')),(0,a.kt)("h2",{id:"updates"},"Updates"),(0,a.kt)("p",null,"TODO: details"),(0,a.kt)("h2",{id:"deletes"},"Deletes"),(0,a.kt)("p",null,"TODO: details"),(0,a.kt)("h2",{id:"transactions"},"Transactions"),(0,a.kt)("p",null,"TODO: details"),(0,a.kt)("h2",{id:"printing-queries"},"Printing queries"),(0,a.kt)("p",null,"TODO: details"),(0,a.kt)("h2",{id:"running-queries"},"Running queries"),(0,a.kt)("p",null,"TODO: details"))}c.isMDXComponent=!0}}]);