"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[37226],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>k});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),m=p(n),u=o,k=m["".concat(s,".").concat(u)]||m[u]||d[u]||i;return n?a.createElement(k,r(r({ref:t},c),{},{components:n})):a.createElement(k,r({ref:t},c))}));function k(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[m]="string"==typeof e?e:o,r[1]=l;for(var p=2;p<i;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},34752:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>m,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var a=n(87462),o=(n(67294),n(3905));const i={id:"zio-mock",title:"ZIO Mock"},r=void 0,l={unversionedId:"ecosystem/officials/zio-mock",id:"ecosystem/officials/zio-mock",title:"ZIO Mock",description:"Installation",source:"@site/docs/ecosystem/officials/zio-mock.md",sourceDirName:"ecosystem/officials",slug:"/ecosystem/officials/zio-mock",permalink:"/ecosystem/officials/zio-mock",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/ecosystem/officials/zio-mock.md",tags:[],version:"current",frontMatter:{id:"zio-mock",title:"ZIO Mock"}},s={},p=[{value:"Installation",id:"installation",level:2},{value:"The Problem",id:"the-problem",level:2},{value:"The Solution",id:"the-solution",level:2},{value:"Mocking Collaborators",id:"mocking-collaborators",level:2},{value:"Testing the Service",id:"testing-the-service",level:2},{value:"Built-in Mock Services",id:"built-in-mock-services",level:2},{value:"Creating a Mock Service",id:"creating-a-mock-service",level:2},{value:"Encoding Service Capabilities",id:"encoding-service-capabilities",level:2},{value:"Encoding Zero Argument Capability",id:"encoding-zero-argument-capability",level:3},{value:"Encoding Multiple Arguments Capability",id:"encoding-multiple-arguments-capability",level:3},{value:"Encoding Overloaded Capabilities",id:"encoding-overloaded-capabilities",level:3},{value:"Encoding Polymorphic Capabilities",id:"encoding-polymorphic-capabilities",level:3},{value:"Defining a Layer for the Mocked Service",id:"defining-a-layer-for-the-mocked-service",level:2},{value:"The Complete Example",id:"the-complete-example",level:2},{value:"More examples",id:"more-examples",level:2},{value:"Defining Expectations",id:"defining-expectations",level:2},{value:"Providing Mocked Environment",id:"providing-mocked-environment",level:3},{value:"Mocking Unused Collaborators",id:"mocking-unused-collaborators",level:3},{value:"Mocking Multiple Collaborators",id:"mocking-multiple-collaborators",level:3},{value:"Expectations",id:"expectations",level:2},{value:"<code>value</code>",id:"value",level:3},{value:"<code>valueF</code>",id:"valuef",level:3},{value:"<code>valueZIO</code>",id:"valuezio",level:3},{value:"<code>unit</code>",id:"unit",level:3},{value:"<code>failure</code>",id:"failure",level:3},{value:"<code>never</code>",id:"never",level:3},{value:"Composing Expectations",id:"composing-expectations",level:2},{value:"<code>and</code>",id:"and",level:3},{value:"<code>or</code>",id:"or",level:3},{value:"<code>andThen</code>",id:"andthen",level:3},{value:"Exact Repetition",id:"exact-repetition",level:3},{value:"Range of Repetitions",id:"range-of-repetitions",level:3}],c={toc:p};function m(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"installation"},"Installation"),(0,o.kt)("p",null,"In order to use this library, we need to add the following line in our ",(0,o.kt)("inlineCode",{parentName:"p"},"build.sbt")," file:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'libraryDependencies += "dev.zio" %% "zio-mock" % <version>\n')),(0,o.kt)("h2",{id:"the-problem"},"The Problem"),(0,o.kt)("p",null,"Whenever possible, we should strive to make our functions pure, which makes testing such function easy. So we just need to assert on the return value. However, in larger applications there is a need for intermediate layers that delegate the work to specialized services."),(0,o.kt)("p",null,"For example, in an HTTP server, the first layers of indirection are so-called ",(0,o.kt)("em",{parentName:"p"},"routes"),", whose job is to match the request and delegate the processing to downstream layers. Below this layer, there is often a second layer of indirection, so-called ",(0,o.kt)("em",{parentName:"p"},"controllers"),", which comprises several business logic units grouped by their domain. In a RESTful API, that would be all operations on a certain model. The ",(0,o.kt)("em",{parentName:"p"},"controller")," to perform its job might call on further specialized services for communicating with the database, sending email, logging, etc."),(0,o.kt)("p",null,"If the job of the ",(0,o.kt)("em",{parentName:"p"},"capability")," is to call on another ",(0,o.kt)("em",{parentName:"p"},"capability"),", how should we test it?"),(0,o.kt)("p",null,"Let's say we have a ",(0,o.kt)("inlineCode",{parentName:"p"},"Userservice")," defined as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\ntrait UserService {\n  def register(username: String, age: Int, email: String): IO[String, Unit]\n}\n\nobject UserService {\n  def register(username: String, age: Int, email: String): ZIO[UserService, String, Unit] =\n    ZIO.serviceWithZIO(_.register(username, age, email))\n}\n")),(0,o.kt)("p",null,"The live implementation of the ",(0,o.kt)("inlineCode",{parentName:"p"},"UserService")," has two collaborators, ",(0,o.kt)("inlineCode",{parentName:"p"},"EmailService")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"UserRepository"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"trait EmailService {\n  def send(to: String, body: String): IO[String, Unit]\n}\n\ncase class User(username: String, age: Int, email: String)\n\ntrait UserRepository {\n  def save(user: User): IO[String, Unit]\n}\n")),(0,o.kt)("p",null,"Following is how the live version of ",(0,o.kt)("inlineCode",{parentName:"p"},"UserService")," is implemented:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'case class UserServiceLive(emailService: EmailService, userRepository: UserRepository) extends UserService {\n  override def register(username: String, age: Int, email: String): IO[String, Unit] =\n    if (age < 18) {\n      emailService.send(email, "You are not eligible to register!")\n    } else if (username == "admin") {\n      ZIO.fail("The admin user is already registered!")\n    } else {\n      for {\n        _ <- userRepository.save(User(username, age, email))\n        _ <- emailService.send(email, "Congratulation, you are registered!")\n      } yield ()\n    }\n}\n\nobject UserServiceLive {\n  val layer: URLayer[EmailService with UserRepository, UserService] =\n    (UserServiceLive.apply _).toLayer[UserService]\n}\n')),(0,o.kt)("p",null,"A pure function is such a function which operates only on its inputs and produces only its output. Command-like methods, by definition are impure, as their job is to change state of the collaborating object (performing a ",(0,o.kt)("em",{parentName:"p"},"side effect"),"). For example:"),(0,o.kt)("p",null,"The signature of ",(0,o.kt)("inlineCode",{parentName:"p"},"register")," method ",(0,o.kt)("inlineCode",{parentName:"p"},"(String, Int, String) => IO[String, Unit]")," hints us we're dealing with a command. It returns ",(0,o.kt)("inlineCode",{parentName:"p"},"Unit")," (well, wrapped in the ",(0,o.kt)("inlineCode",{parentName:"p"},"IO"),", but it does not matter here). We can't do anything useful with ",(0,o.kt)("inlineCode",{parentName:"p"},"Unit"),", and it does not contain any information. It is the equivalent of returning nothing."),(0,o.kt)("p",null,"It is also an unreliable return type, as when Scala expects the return type to be ",(0,o.kt)("inlineCode",{parentName:"p"},"Unit")," it will discard whatever value it had (for details see ",(0,o.kt)("a",{parentName:"p",href:"https://scala-lang.org/files/archive/spec/2.13/06-expressions.html#value-conversions"},"Section 6.26.1")," of the Scala Language Specification), which may shadow the fact that the final value produced (and discarded) was not the one we expected."),(0,o.kt)("p",null,"Inside the ",(0,o.kt)("inlineCode",{parentName:"p"},"IO")," there may be a description of any side effects. It may open a file, print to the console, or connect to databases. ",(0,o.kt)("strong",{parentName:"p"},'So the problem is "How is it possible to test a service along with its collaborators"?')),(0,o.kt)("p",null,"In this example, the ",(0,o.kt)("inlineCode",{parentName:"p"},"register")," method has a service call to its collaborators, ",(0,o.kt)("inlineCode",{parentName:"p"},"UserRepository")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"EmailService"),".  So, how can we test the live version of ",(0,o.kt)("inlineCode",{parentName:"p"},"UserService.register")," while it has some side effects in communicating with its collaborators?"),(0,o.kt)("p",null,"Mockists would probably claim that testing how collaborators are called during the test process allows us to test the UserService. Let's move on to the next section and see the mockists' solution in greater detail."),(0,o.kt)("h2",{id:"the-solution"},"The Solution"),(0,o.kt)("p",null,"In this sort of situations we need mock implementations of our ",(0,o.kt)("em",{parentName:"p"},"collaborator service"),". As ",(0,o.kt)("em",{parentName:"p"},"Martin Fowler")," puts it in his excellent article ",(0,o.kt)("a",{parentName:"p",href:"https://martinfowler.com/articles/mocksArentStubs.html"},"Mocks Aren't Stubs"),":"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"Mocks")," are (...) objects pre-programmed with expectations which form a specification of the calls they are expected to receive.")),(0,o.kt)("p",null,"So to test the ",(0,o.kt)("inlineCode",{parentName:"p"},"register")," function, we can mock the behavior of its two collaborators. So instead of using production objects, we use pre-programmed mock versions of these two collaborators with some expectations. In this way, in each test case, we expect these collaborators will be called with expected inputs."),(0,o.kt)("p",null,"In this example, we can define these three test cases:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"If we register a user with an age of less than 18, we expect that the ",(0,o.kt)("inlineCode",{parentName:"li"},"save")," method of ",(0,o.kt)("inlineCode",{parentName:"li"},"UserRepository")," shouldn't be called. Additionally, we expect that the ",(0,o.kt)("inlineCode",{parentName:"li"},"send")," method of ",(0,o.kt)("inlineCode",{parentName:"li"},"EmailService"),' will be called with the following content: "You are not eligible to register."'),(0,o.kt)("li",{parentName:"ol"},'If we register a user with a username of "admin", we expect that both ',(0,o.kt)("inlineCode",{parentName:"li"},"UserRepository")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"EmailService")," should not be called. Instead, we expect that the ",(0,o.kt)("inlineCode",{parentName:"li"},"register"),' call will be failed with a proper failure value: "The admin user is already registered!"'),(0,o.kt)("li",{parentName:"ol"},"Otherwise, we expect that the ",(0,o.kt)("inlineCode",{parentName:"li"},"save")," method of ",(0,o.kt)("inlineCode",{parentName:"li"},"UserRepository")," will be called with the corresponding ",(0,o.kt)("inlineCode",{parentName:"li"},"User")," object, and the ",(0,o.kt)("inlineCode",{parentName:"li"},"send")," method of ",(0,o.kt)("inlineCode",{parentName:"li"},"EmailService"),' will be called with this content: "Congratulation, you are registered!".')),(0,o.kt)("p",null,"ZIO Test provides a framework for mocking our modules. In the next section, we are going to test ",(0,o.kt)("inlineCode",{parentName:"p"},"UserService")," by mocking its collaborators."),(0,o.kt)("h2",{id:"mocking-collaborators"},"Mocking Collaborators"),(0,o.kt)("p",null,"In the previous section, we learned we can test the ",(0,o.kt)("inlineCode",{parentName:"p"},"UserService")," by mocking its collaborators. Let's see how we can mock the ",(0,o.kt)("inlineCode",{parentName:"p"},"EmailService")," and also the ",(0,o.kt)("inlineCode",{parentName:"p"},"UserRepository"),"."),(0,o.kt)("p",null,"We should create a mock object by extending ",(0,o.kt)("inlineCode",{parentName:"p"},"Mock[EmailService]")," (",(0,o.kt)("inlineCode",{parentName:"p"},"zio.mock.Mock"),"). Then we need to define the following objects:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Capability tags")," \u2014 They are value objects which extend one of the ",(0,o.kt)("inlineCode",{parentName:"li"},"Capability[R, I, E, A]")," data types, such as ",(0,o.kt)("inlineCode",{parentName:"li"},"Effect"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"Method"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"Sink"),", or ",(0,o.kt)("inlineCode",{parentName:"li"},"Stream"),". For each of the service capabilities, we need to create an object extending one of these data types. They encode the type of ",(0,o.kt)("em",{parentName:"li"},"environments"),", ",(0,o.kt)("em",{parentName:"li"},"arguments")," (inputs), the ",(0,o.kt)("em",{parentName:"li"},"error channel"),", and also the ",(0,o.kt)("em",{parentName:"li"},"success channel")," of each capability of the service.")),(0,o.kt)("p",null,"For example, to encode the ",(0,o.kt)("inlineCode",{parentName:"p"},"send")," capability of ",(0,o.kt)("inlineCode",{parentName:"p"},"EmailService")," we need to extend the ",(0,o.kt)("inlineCode",{parentName:"p"},"Effect")," capability as bellow:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"object Send extends Effect[(String, String), String, Unit]\n")),(0,o.kt)("ol",{start:2},(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Compose layer")," \u2014 In this step, we need to provide a layer in which used to construct the mocked object. In order to do that, we should obtain the ",(0,o.kt)("inlineCode",{parentName:"li"},"Proxy")," data type from the environment and then implement the service interface (i.e. ",(0,o.kt)("inlineCode",{parentName:"li"},"EmailService"),") by wrapping all capability tags with proxy.")),(0,o.kt)("p",null,"Let's see how we can mock the ",(0,o.kt)("inlineCode",{parentName:"p"},"EmailService"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"// Test Sources\nimport zio.mock._\n\nobject MockEmailService extends Mock[EmailService] {\n  object Send extends Effect[(String, String), String, Unit]\n\n  val compose: URLayer[Proxy, EmailService] =\n    ZIO\n      .service[Proxy]\n      .map { proxy =>\n        new EmailService {\n          override def send(to: String, body: String): IO[String, Unit] =\n            proxy(Send, to, body)\n        }\n      }\n      .toLayer\n}\n")),(0,o.kt)("p",null,"And, here is the mock version of the ",(0,o.kt)("inlineCode",{parentName:"p"},"UserRepository"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\nimport zio.mock._\n\nobject MockUserRepository extends Mock[UserRepository] {\n  object Save extends Effect[User, String, Unit]\n\n  val compose: URLayer[Proxy, UserRepository] =\n    ZIO\n      .service[Proxy]\n      .map { proxy =>\n        new UserRepository {\n          override def save(user: User): IO[String, Unit] =\n            proxy(Save, user)\n        }\n      }\n      .toLayer\n}\n")),(0,o.kt)("h2",{id:"testing-the-service"},"Testing the Service"),(0,o.kt)("p",null,"After writing the mock version of collaborators, now we can use their ",(0,o.kt)("em",{parentName:"p"},"capability tags")," to convert them to the ",(0,o.kt)("inlineCode",{parentName:"p"},"Expectation"),", and finally create the mock layer of the service."),(0,o.kt)("p",null,"For example, we can create an expectation from the ",(0,o.kt)("inlineCode",{parentName:"p"},"Send")," capability tag of the ",(0,o.kt)("inlineCode",{parentName:"p"},"MockEmailService"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.test._\n\nval sendEmailExpectation: Expectation[EmailService] =\n  MockEmailService.Send(\n    assertion = Assertion.equalTo(("john@doe", "You are not eligible to register!")),\n    result = Expectation.unit\n  )\n')),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"sendEmailExpectation")," is an expectation, which requires a call to ",(0,o.kt)("inlineCode",{parentName:"p"},"send")," method with ",(0,o.kt)("inlineCode",{parentName:"p"},'("john@doe", "You are not eligible to register!")')," arguments. If this service will be called, the returned value would be ",(0,o.kt)("inlineCode",{parentName:"p"},"unit"),"."),(0,o.kt)("p",null,"There is an extension method called ",(0,o.kt)("inlineCode",{parentName:"p"},"Expectation#toLayer")," which implicitly converts an expectation to the ",(0,o.kt)("inlineCode",{parentName:"p"},"ZLayer")," environment:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.test._\n\nval mockEmailService: ULayer[EmailService] =\n  MockEmailService.Send(\n    assertion = Assertion.equalTo(("john@doe", "You are not eligible to register!")),\n    result = Expectation.unit\n  ).toLayer\n')),(0,o.kt)("p",null,"So we do not require to convert them to ",(0,o.kt)("inlineCode",{parentName:"p"},"ZLayer")," explicitly. It will convert them whenever required."),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Now let's test the first scenario discussed in the ",(0,o.kt)("a",{parentName:"li",href:"#the-solution"},"solution")," section:")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"If we register a user with an age of less than 18, we expect that the ",(0,o.kt)("inlineCode",{parentName:"p"},"save")," method of ",(0,o.kt)("inlineCode",{parentName:"p"},"UserRepository")," shouldn't be called. Additionally, we expect that the ",(0,o.kt)("inlineCode",{parentName:"p"},"send")," method of ",(0,o.kt)("inlineCode",{parentName:"p"},"EmailService"),' will be called with the following content: "You are not eligible to register."')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.test._\n\ntest("non-adult registration") {\n  val sut              = UserService.register("john", 15, "john@doe")\n  val liveUserService  = UserServiceLive.layer\n  val mockUserRepo     = MockUserRepository.empty\n  val mockEmailService = MockEmailService.Send(\n    assertion = Assertion.equalTo(("john@doe", "You are not eligible to register!")),\n    result = Expectation.unit\n  )\n\n  for {\n    _ <- sut.provide(liveUserService, mockUserRepo, mockEmailService)\n  } yield assertTrue(true)\n}\n')),(0,o.kt)("p",null,"We used ",(0,o.kt)("inlineCode",{parentName:"p"},"MockUserRepository.empty")," since we expect no call to the ",(0,o.kt)("inlineCode",{parentName:"p"},"UserRepository")," service."),(0,o.kt)("ol",{start:2},(0,o.kt)("li",{parentName:"ol"},"The second scenario is:")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},'If we register a user with a username of "admin", we expect that both ',(0,o.kt)("inlineCode",{parentName:"p"},"UserRepository")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"EmailService")," should not be called. Instead, we expect that the ",(0,o.kt)("inlineCode",{parentName:"p"},"register"),' call will be failed with a proper failure value: "The admin user is already registered!"')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.test._\n\ntest("user cannot register pre-defined admin user") {\n  val sut = UserService.register("admin", 30, "admin@doe")\n\n  for {\n    result <- sut.provide(\n      UserServiceLive.layer,\n      MockEmailService.empty,\n      MockUserRepository.empty\n    ).exit\n  } yield assertTrue(\n    result match {\n      case Exit.Failure(cause)\n        if cause.contains(\n          Cause.fail("The admin user is already registered!")\n        ) => true\n      case _ => false\n    }\n  )\n}\n')),(0,o.kt)("ol",{start:3},(0,o.kt)("li",{parentName:"ol"},"Finally, we have to check the ",(0,o.kt)("em",{parentName:"li"},"happy path")," scenario:")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"We expect that the ",(0,o.kt)("inlineCode",{parentName:"p"},"save")," method of ",(0,o.kt)("inlineCode",{parentName:"p"},"UserRepository")," will be called with the corresponding ",(0,o.kt)("inlineCode",{parentName:"p"},"User")," object, and the ",(0,o.kt)("inlineCode",{parentName:"p"},"send")," method of ",(0,o.kt)("inlineCode",{parentName:"p"},"EmailService"),' will be called with this content: "Congratulation, you are registered!".')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.test._\n\ntest("a valid user can register to the user service") {\n  val sut              = UserService.register("jane", 25, "jane@doe")\n  val liveUserService  = UserServiceLive.layer\n  val mockUserRepo     = MockUserRepository.Save(\n    Assertion.equalTo(User("jane", 25, "jane@doe")),\n    Expectation.unit\n  )\n  val mockEmailService = MockEmailService.Send(\n    assertion = Assertion.equalTo(("jane@doe", "Congratulation, you are registered!")),\n    result = Expectation.unit\n  )\n\n  for {\n    _ <- sut.provide(liveUserService, mockUserRepo, mockEmailService)\n  } yield assertTrue(true)\n}\n')),(0,o.kt)("h2",{id:"built-in-mock-services"},"Built-in Mock Services"),(0,o.kt)("p",null,"For each built-in ZIO service, we will find their mockable counterparts in ",(0,o.kt)("inlineCode",{parentName:"p"},"zio.mock")," package:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"[",(0,o.kt)("inlineCode",{parentName:"li"},"MockClock"),"]"," for ",(0,o.kt)("inlineCode",{parentName:"li"},"zio.Clock")),(0,o.kt)("li",{parentName:"ul"},"[",(0,o.kt)("inlineCode",{parentName:"li"},"MockConsole"),"]"," for ",(0,o.kt)("inlineCode",{parentName:"li"},"zio.Console")),(0,o.kt)("li",{parentName:"ul"},"[",(0,o.kt)("inlineCode",{parentName:"li"},"MockRandom"),"]"," for ",(0,o.kt)("inlineCode",{parentName:"li"},"zio.Random")),(0,o.kt)("li",{parentName:"ul"},"[",(0,o.kt)("inlineCode",{parentName:"li"},"MockSystem"),"]"," for ",(0,o.kt)("inlineCode",{parentName:"li"},"zio.System"))),(0,o.kt)("p",null,"A ",(0,o.kt)("inlineCode",{parentName:"p"},"Mock[R]")," represents a mockable environment ",(0,o.kt)("inlineCode",{parentName:"p"},"R"),". It's a base abstract class for every service we want to mock."),(0,o.kt)("h2",{id:"creating-a-mock-service"},"Creating a Mock Service"),(0,o.kt)("p",null,"In order to create a mock object, we should define an object which implements the ",(0,o.kt)("inlineCode",{parentName:"p"},"Mock")," abstract class in the test sources. To implement the ",(0,o.kt)("inlineCode",{parentName:"p"},"Mock")," need to define ",(0,o.kt)("em",{parentName:"p"},"capability tags")," and the ",(0,o.kt)("em",{parentName:"p"},"compose layer"),":"),(0,o.kt)("h2",{id:"encoding-service-capabilities"},"Encoding Service Capabilities"),(0,o.kt)("p",null,"Capabilities are service functionalities that are accessible from the client-side. For example, in the following service the ",(0,o.kt)("inlineCode",{parentName:"p"},"send")," method is a service capability:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\ntrait UserService {\n  def register(username: String, age: Int, email: String): Task[Unit]\n}\n")),(0,o.kt)("p",null,"A ",(0,o.kt)("strong",{parentName:"p"},"capability tag")," encodes all information needed to mock the target capability. It is just a value that extends the ",(0,o.kt)("inlineCode",{parentName:"p"},"zio.mock.Capability[R, I, E, A]")," type constructor, where:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"R")," is the type of ",(0,o.kt)("em",{parentName:"li"},"environment")," the method belongs to"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"I")," is the type of ",(0,o.kt)("em",{parentName:"li"},"methods input arguments")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"E")," is the type of ",(0,o.kt)("em",{parentName:"li"},"error")," it can fail with"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"A")," is the type of ",(0,o.kt)("em",{parentName:"li"},"return value")," it can produce")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"Capability")," type is not publicly available, instead we have to extend ",(0,o.kt)("inlineCode",{parentName:"p"},"Mock")," dependent types ",(0,o.kt)("inlineCode",{parentName:"p"},"Effect"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"Method"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"Sink")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"Stream"),"."),(0,o.kt)("p",null,"We can have 4 types of capabilities inside a service:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"strong"},"Effect"))," \u2014 describes an effectful ZIO operation"),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"strong"},"Method"))," \u2014 describes an ordinary scala function"),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"strong"},"Sink"))," \u2014 describes an effectful ZIO Sink"),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"strong"},"Stream"))," \u2014 describes an effectful ZIO Stream")),(0,o.kt)("p",null,"Let's say we have the following service:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\nimport zio.mock._\nimport zio.stream._\n\ntrait ExampleService {\n  def exampleEffect(i: Int): Task[String]\n  def exampleMethod(i: Int): String\n  def exampleSink(a: Int): Sink[Throwable, Int, Nothing, List[Int]]\n  def exampleStream(a: Int): Stream[Throwable, String]\n}\n")),(0,o.kt)("p",null,"Therefore, the mock service should have the following ",(0,o.kt)("em",{parentName:"p"},"capability tags"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import zio.mock._\n\nobject MockExampleService extends Mock[ExampleService] {\n  object ExampleEffect extends Effect[Int, Throwable, String]\n  object ExampleMethod extends Method[Int, Throwable, String]\n  object ExampleSink   extends Sink[Any, Throwable, Int, Nothing, List[Int]]\n  object ExampleStream extends Stream[Int, Throwable, String]\n  \n  override val compose: URLayer[Proxy, ExampleService] = ???\n}\n")),(0,o.kt)("p",null,"In this example, all ",(0,o.kt)("inlineCode",{parentName:"p"},"ExampleEffect"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"ExampleMethod"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"ExampleSink"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"ExampleStream")," are capability tags. Each of these capability tags encodes all information needed to mock the target capability."),(0,o.kt)("p",null,"For example, the ",(0,o.kt)("inlineCode",{parentName:"p"},"ExampleEffect")," capability tag encodes the type of ",(0,o.kt)("em",{parentName:"p"},"environments"),", ",(0,o.kt)("em",{parentName:"p"},"arguments")," (inputs), the ",(0,o.kt)("em",{parentName:"p"},"error channel"),", and also the ",(0,o.kt)("em",{parentName:"p"},"success channel")," of the ",(0,o.kt)("inlineCode",{parentName:"p"},"exampleEffect(i: Int)")," method."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"")),(0,o.kt)("p",null,"We encode service capabilities according to the following scheme:"),(0,o.kt)("h3",{id:"encoding-zero-argument-capability"},"Encoding Zero Argument Capability"),(0,o.kt)("p",null,"For zero arguments the type is ",(0,o.kt)("inlineCode",{parentName:"p"},"Unit")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\ntrait ZeroParamService {\n  def zeroParams: Task[Int]\n}\n")),(0,o.kt)("p",null,"So the capability tag of ",(0,o.kt)("inlineCode",{parentName:"p"},"zeroParams")," should be:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import zio.mock._\n\nobject MockZeroParamService extends Mock[ZeroParamService] {\n  object ZeroParams extends Effect[Unit, Throwable, Int]\n  \n  override val compose = ???\n}\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"")),(0,o.kt)("h3",{id:"encoding-multiple-arguments-capability"},"Encoding Multiple Arguments Capability"),(0,o.kt)("p",null,"For one or more arguments, regardless of how many parameter lists, the type is a ",(0,o.kt)("inlineCode",{parentName:"p"},"TupleN")," where ",(0,o.kt)("inlineCode",{parentName:"p"},"N")," is the size of arguments list"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"Note:")),(0,o.kt)("p",{parentName:"blockquote"},"We're using tuples to represent multiple argument methods, which follows with a limit to max 22 arguments, as is Scala itself limited.")),(0,o.kt)("p",null,"If the capability has more than one argument, we should encode the argument types in the ",(0,o.kt)("inlineCode",{parentName:"p"},"Tuple")," data type. For example, if we have the following service:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\ntrait ManyParamsService {\n  def manyParams(a: Int, b: String, c: Long): Task[Int]\n  def manyParamLists(a: Int, b: String)(c: Long): Task[Int]\n}\n")),(0,o.kt)("p",null,"We should encode that with the following capability tag:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import zio.mock._\n\ntrait MockExampleService extends Mock[ManyParamsService] {\n  object ManyParams     extends Method[(Int, String, Long), Throwable, String]\n  object ManyParamLists extends Method[(Int, String, Long), Throwable, String]\n  \n  override val compose = ???\n}\n")),(0,o.kt)("h3",{id:"encoding-overloaded-capabilities"},"Encoding Overloaded Capabilities"),(0,o.kt)("p",null,"For overloaded methods, we nest a list of numbered objects, each representing subsequent overloads:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"// Main sources\n\nimport zio._\nimport zio.stream.{ ZSink, ZStream }\n\ntrait OverloadedService {\n  def overloaded(arg1: Int)                  : UIO[String]\n  def overloaded(arg1: Long)                 : UIO[String]\n}\n")),(0,o.kt)("p",null,"We encode both overloaded capabilities by using numbered objects inside a nested object:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"// Test sources\n\nimport zio._\nimport zio.mock._\n\nobject MockOervloadedService extends Mock[OverloadedService] {\n  object Overloaded {\n    object _0 extends Effect[Int, Nothing, String]\n    object _1 extends Effect[Long, Nothing, String]\n  }\n\n  val compose: URLayer[Proxy, OverloadedService] = ???\n}\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"")),(0,o.kt)("h3",{id:"encoding-polymorphic-capabilities"},"Encoding Polymorphic Capabilities"),(0,o.kt)("p",null,"Mocking polymorphic methods is also supported, but the interface must require ",(0,o.kt)("inlineCode",{parentName:"p"},"zio.Tag")," implicit evidence for each type parameter:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"// main sources\nimport zio._\n\ntrait PolyService {\n  def polyInput[I: Tag](input: I): Task[String]\n  def polyError[E: Tag](input: Int): IO[E, String]\n  def polyOutput[A: Tag](input: Int): Task[A]\n  def polyAll[I: Tag, E: Tag, A: Tag](input: I): IO[E, A]\n}\n")),(0,o.kt)("p",null,"In the test sources we construct partially applied ",(0,o.kt)("em",{parentName:"p"},"capability tags")," by extending ",(0,o.kt)("inlineCode",{parentName:"p"},"Method.Poly")," family. The unknown types must be provided at call site. To produce a final monomorphic ",(0,o.kt)("inlineCode",{parentName:"p"},"Method")," tag we must use the ",(0,o.kt)("inlineCode",{parentName:"p"},"of")," combinator and pass the missing types:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"// test sources\nimport zio.mock._\n\nobject MockPolyService extends Mock[PolyService] {\n\n  object PolyInput  extends Poly.Effect.Input[Throwable, String]\n  object PolyError  extends Poly.Effect.Error[Int, String]\n  object PolyOutput extends Poly.Effect.Output[Int, Throwable]\n  object PolyAll    extends Poly.Effect.InputErrorOutput\n\n  // We will learn about the compose layer in the next section\n  val compose: URLayer[Proxy, PolyService] =\n    ZIO.serviceWithZIO[Proxy] { proxy =>\n      withRuntime[Any].map { rts =>\n        new PolyService {\n          def polyInput[I: Tag](input: I)               = proxy(PolyInput.of[I], input)\n          def polyError[E: Tag](input: Int)             = proxy(PolyError.of[E], input)\n          def polyOutput[A: Tag](input: Int)            = proxy(PolyOutput.of[A], input)\n          def polyAll[I: Tag, E: Tag, A: Tag](input: I) = proxy(PolyAll.of[I, E, A], input)\n        }\n      }\n    }.toLayer\n}\n")),(0,o.kt)("p",null,"Similarly, we use the same ",(0,o.kt)("inlineCode",{parentName:"p"},"of")," combinator to refer to concrete monomorphic call in our test suite when building expectations:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.test._\nimport MockPolyService._\n\nval exp06 = PolyInput.of[String](\n  Assertion.equalTo("foo"),\n  Expectation.value("bar")\n)\n\nval exp07 = PolyInput.of[Int](\n  Assertion.equalTo(42),\n  Expectation.failure(new Exception)\n)\n\nval exp08 = PolyInput.of[Long](\n  Assertion.equalTo(42L),\n  Expectation.value("baz")\n)\n\nval exp09 = PolyAll.of[Int, Throwable, String](\n  Assertion.equalTo(42),\n  Expectation.value("foo")\n)\n\nval exp10 = PolyAll.of[Int, Throwable, String](\n  Assertion.equalTo(42),\n  Expectation.failure(new Exception)\n)\n')),(0,o.kt)("h2",{id:"defining-a-layer-for-the-mocked-service"},"Defining a Layer for the Mocked Service"),(0,o.kt)("p",null,"Finally, we need to define a ",(0,o.kt)("em",{parentName:"p"},"compose layer")," that can create our environment from a ",(0,o.kt)("inlineCode",{parentName:"p"},"Proxy"),". A ",(0,o.kt)("inlineCode",{parentName:"p"},"Proxy")," holds the mock state and serves predefined responses to calls."),(0,o.kt)("p",null,"So again, assume we have the following service:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\nimport zio.mock._\n\ntrait ExampleService {\n  def exampleEffect(i: Int): Task[String]\n  def exampleMethod(i: Int): String\n  def exampleSink(a: Int): stream.Sink[Throwable, Int, Nothing, List[Int]]\n  def exampleStream(a: Int): stream.Stream[Throwable, String]\n}\n")),(0,o.kt)("p",null,"In this step, we need to provide a layer in which used to construct the mocked object. To do that, we should obtain the ",(0,o.kt)("inlineCode",{parentName:"p"},"Proxy")," data type from the environment and then implement the service interface by wrapping all capability tags with proxy:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import zio.mock._\n\nobject MockExampleService extends Mock[ExampleService] {\n  object ExampleEffect extends Effect[Int, Throwable, String]\n  object ExampleMethod extends Method[Int, Throwable, String]\n  object ExampleSink extends Sink[Any, Throwable, Int, Nothing, List[Int]]\n  object ExampleStream extends Stream[Int, Throwable, String]\n\n  override val compose: URLayer[Proxy, ExampleService] =\n    ZIO.serviceWithZIO[Proxy] { proxy =>\n      withRuntime[Any].map { rts =>\n        new ExampleService {\n          override def exampleEffect(i: Int): Task[String] =\n            proxy(ExampleEffect, i)\n\n          override def exampleMethod(i: Int): String =\n            rts.unsafeRunTask(proxy(ExampleMethod, i))\n\n          override def exampleSink(a: Int): stream.Sink[Throwable, Int, Nothing, List[Int]] =\n            rts.unsafeRun(proxy(ExampleSink, a))\n\n          override def exampleStream(a: Int): stream.Stream[Throwable, String] =\n            rts.unsafeRun(proxy(ExampleStream, a))\n        }\n      }\n    }.toLayer\n}\n")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"Note:")," The ",(0,o.kt)("inlineCode",{parentName:"p"},"withRuntime")," helper is defined in ",(0,o.kt)("inlineCode",{parentName:"p"},"Mock"),". It accesses the Runtime via ",(0,o.kt)("inlineCode",{parentName:"p"},"ZIO.runtime")," and if you're on JS platform, it will replace the executor to an unyielding one.")),(0,o.kt)("p",null,"A reference to this layer is passed to ",(0,o.kt)("em",{parentName:"p"},"capability tags"),", so it can be used to automatically build environment for composed expectations on multiple services."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"")),(0,o.kt)("h2",{id:"the-complete-example"},"The Complete Example"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"trait AccountEvent\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'// main sources\n\nimport zio._\nimport zio.mock._\n\ntrait AccountObserver {\n  def processEvent(event: AccountEvent): UIO[Unit]\n  def runCommand(): UIO[Unit]\n}\n\nobject AccountObserver {\n  def processEvent(event: AccountEvent) =\n    ZIO.serviceWithZIO[AccountObserver](_.processEvent(event))\n\n  def runCommand() =\n    ZIO.serviceWithZIO[AccountObserver](_.runCommand())\n}\n\ncase class AccountObserverLive(console: Console) extends AccountObserver {\n  def processEvent(event: AccountEvent): UIO[Unit] =\n    for {\n      _    <- console.printLine(s"Got $event").orDie\n      line <- console.readLine.orDie\n      _    <- console.printLine(s"You entered: $line").orDie\n    } yield ()\n\n  def runCommand(): UIO[Unit] =\n    console.printLine("Done!").orDie\n}\n\nobject AccountObserverLive {\n  val layer = (AccountObserverLive.apply _).toLayer[AccountObserver]\n}\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"// test sources\n\nobject AccountObserverMock extends Mock[AccountObserver] {\n\n  object ProcessEvent extends Effect[AccountEvent, Nothing, Unit]\n  object RunCommand   extends Effect[Unit, Nothing, Unit]\n\n  val compose: URLayer[Proxy, AccountObserver] =\n    ZIO.service[Proxy].map { proxy =>\n      new AccountObserver {\n        def processEvent(event: AccountEvent) = proxy(ProcessEvent, event)\n        def runCommand(): UIO[Unit]           = proxy(RunCommand)\n      }\n    }.toLayer\n}\n")),(0,o.kt)("h2",{id:"more-examples"},"More examples"),(0,o.kt)("p",null,"We can find more examples in the ",(0,o.kt)("inlineCode",{parentName:"p"},"examples")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"test-tests")," subproject:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/zio/zio/blob/master/examples/shared/src/test/scala/zio/examples/test/MockExampleSpec.scala"},"MockExampleSpec")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/zio/zio/blob/master/test-tests/shared/src/test/scala/zio/test/mock/EmptyMockSpec.scala"},"EmptyMockSpec")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/zio/zio/blob/master/test-tests/shared/src/test/scala/zio/test/mock/ComposedMockSpec.scala"},"ComposedMockSpec")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/zio/zio/blob/master/test-tests/shared/src/test/scala/zio/test/mock/ComposedEmptyMockSpec.scala"},"ComposedEmptyMockSpec")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/zio/zio/blob/master/test-tests/shared/src/test/scala/zio/test/mock/PolyMockSpec.scala"},"PolyMockSpec"))),(0,o.kt)("p",null,"An ",(0,o.kt)("inlineCode",{parentName:"p"},"Expectation[R]")," is an immutable tree structure that represents expectations on environment ",(0,o.kt)("inlineCode",{parentName:"p"},"R"),"."),(0,o.kt)("h2",{id:"defining-expectations"},"Defining Expectations"),(0,o.kt)("p",null,"ZIO Test has a variety of expectations, such as ",(0,o.kt)("inlineCode",{parentName:"p"},"value"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"unit"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"failure"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"never"),". In this section we are going to learn each of these expectations and their variant, by mocking the ",(0,o.kt)("inlineCode",{parentName:"p"},"UserService")," service. So let's assume we have the following service:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\nimport zio.mock._\nimport zio.test._\n\ncase class User(id: String, name: String)\n\ntrait UserService {\n  def insert(user: User): IO[String, Unit]\n  def remove(id: String): IO[String, Unit]\n  def totalUsers: IO[String, Int]\n  def recentUsers(n: Int): IO[String, List[User]]\n  def removeAll: IO[String, Unit]\n}\n\nobject UserService {\n  def totalUsers: ZIO[UserService, String, Int] =\n    ZIO.serviceWithZIO(_.totalUsers)\n\n  def insert(user: User): ZIO[UserService, String, Unit] =\n    ZIO.serviceWithZIO(_.insert(user))\n\n  def recentUsers(n: Int): ZIO[UserService, String, List[User]] =\n    ZIO.serviceWithZIO(_.recentUsers(n))\n\n  def remove(id: String): ZIO[UserService, String, Unit] =\n    ZIO.serviceWithZIO(_.remove(id))\n   \n  def removeAll: ZIO[UserService, String, Unit] = \n    ZIO.serviceWithZIO(_.removeAll) \n}\n")),(0,o.kt)("p",null,"We can write the mock version of this class as below:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"\nobject MockUserService extends Mock[UserService] {\n\n  object Insert      extends Effect[User, String, Unit]\n  object Remove      extends Effect[String, String, Unit]\n  object RecentUsers extends Effect[Int, String, List[User]]\n  object TotalUsers  extends Effect[Unit, String, Int]\n  object RemoveAll   extends Effect[Unit, String, Unit]\n\n  val compose: URLayer[mock.Proxy, UserService] =\n    ZIO.service[mock.Proxy]\n      .map { proxy =>\n        new UserService {\n          override def insert(user: User):  IO[String, Unit]       = proxy(Insert, user)\n          override def remove(id: String):  IO[String, Unit]       = proxy(Remove, id)\n          override def recentUsers(n: Int): IO[String, List[User]] = proxy(RecentUsers, n)\n          override def totalUsers:          IO[String, Int]        = proxy(TotalUsers)\n          override def removeAll:           IO[String, Unit]       = proxy(RemoveAll)\n        }\n      }.toLayer\n      \n}\n")),(0,o.kt)("p",null,"To create expectations we use the previously defined ",(0,o.kt)("em",{parentName:"p"},"capability tags"),"."),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"For methods that take input, the first argument will be an assertion on input, and the second the predefined result.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.mock._\nimport zio.test._\n\nval exp01 = MockUserService.RecentUsers( // capability to build an expectation for\n  Assertion.equalTo(5), // assertion of the expected input argument\n  Expectation.value(List(User("1", "Jane Doe"), User("2", "John Doe"))) // result, that will be returned\n)\n')),(0,o.kt)("ol",{start:2},(0,o.kt)("li",{parentName:"ol"},"For methods that take no input, we only define the expected output:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"val exp02 = MockUserService.TotalUsers(Expectation.value(42))\n")),(0,o.kt)("ol",{start:3},(0,o.kt)("li",{parentName:"ol"},"For methods that may return ",(0,o.kt)("inlineCode",{parentName:"li"},"Unit"),", we may skip the predefined result (it will default to successful value) or use ",(0,o.kt)("inlineCode",{parentName:"li"},"unit")," helper:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'val exp03 = MockUserService.Remove(\n  Assertion.equalTo("1"),\n  Expectation.unit\n)\n')),(0,o.kt)("ol",{start:4},(0,o.kt)("li",{parentName:"ol"},"For methods that may return ",(0,o.kt)("inlineCode",{parentName:"li"},"Unit")," and take no input we can skip both:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"val exp04 = MockUserService.RemoveAll()\n")),(0,o.kt)("h3",{id:"providing-mocked-environment"},"Providing Mocked Environment"),(0,o.kt)("p",null,"Each expectation can be taught of a mocked environment. They can be converted to a ",(0,o.kt)("inlineCode",{parentName:"p"},"ZLayer")," implicitly. Therefore, we can compose them together and provide them to the environment of the SUT (System Under Test)."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.test._\n\nimport zio._\nimport zio.mock._\nimport zio.test.{test, _}\n\ntest("expecting simple value on call to nextInt") {\n  val sut     = Random.nextInt\n  val mockEnv = MockRandom.NextInt(Expectation.value(5))\n  for {\n    total <- sut.provideLayer(mockEnv)\n  } yield assertTrue(total == 5)\n} \n')),(0,o.kt)("h3",{id:"mocking-unused-collaborators"},"Mocking Unused Collaborators"),(0,o.kt)("p",null,"Often the dependency on a collaborator is only in some branches of the code. To test the correct behaviour of branches without dependencies, we still have to provide it to the environment, but we would like to assert it was never called. With the ",(0,o.kt)("inlineCode",{parentName:"p"},"Mock.empty")," method we can obtain a ",(0,o.kt)("inlineCode",{parentName:"p"},"ZLayer")," with an empty service (no calls expected):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.mock._\nimport zio.test._\n\nobject MaybeConsoleSpec extends MockSpecDefault {\n  def spec = suite("processEvent")(\n    test("expect no call") {\n      def maybeConsole(invokeConsole: Boolean) =\n        ZIO.when(invokeConsole)(Console.printLine("foo"))\n\n      val sut1     = maybeConsole(false).unit\n      val mockEnv1 = MockConsole.empty\n\n      val sut2     = maybeConsole(true).unit\n      val mockEnv2 = MockConsole.PrintLine(\n        Assertion.equalTo("foo"),\n        Expectation.unit\n      )\n\n      for {\n        _ <- sut1.provideLayer(mockEnv1)\n        _ <- sut2.provideLayer(mockEnv2)\n      } yield assertTrue(true)\n    }\n  )\n}\n')),(0,o.kt)("h3",{id:"mocking-multiple-collaborators"},"Mocking Multiple Collaborators"),(0,o.kt)("p",null,"In some cases we have more than one collaborating service being called. We can create mocks for rich environments and as you enrich the environment by using ",(0,o.kt)("em",{parentName:"p"},"capability tags")," from another service, the underlying mocked layer will be updated."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.mock._\nimport zio.test.{test, _}\n\ntest("mocking multiple collaborators") {\n  val sut =\n    for {\n      _ <- Console.printLine("What is your name?")\n      name <- Console.readLine.orDie\n      num <- Random.nextInt\n      _ <- Console.printLine(s"$name, your lucky number today is $num!")\n    } yield ()\n\n  val mockEnv: ULayer[Console with Random] = MockConsole.PrintLine(\n    Assertion.equalTo("What is your name?"),\n    Expectation.unit\n  ) ++ MockConsole.ReadLine(Expectation.value("Mike")) ++\n    MockRandom.NextInt(Expectation.value(42)) ++\n    MockConsole.PrintLine(\n      Assertion.equalTo("Mike, your lucky number today is 42!"),\n      Expectation.unit\n    )\n    \n  for {\n    _ <- sut.provideLayer(mockEnv)\n  } yield assertTrue(true)\n} \n')),(0,o.kt)("h2",{id:"expectations"},"Expectations"),(0,o.kt)("p",null,"In the most robust example, the result can be either a successful value or a failure. In this section we are going to introduce all these cases, by using the proper expectation from ",(0,o.kt)("inlineCode",{parentName:"p"},"zio.mock.Expectation")," companion object:"),(0,o.kt)("h3",{id:"value"},(0,o.kt)("inlineCode",{parentName:"h3"},"value")),(0,o.kt)("p",null,"Expecting a simple value:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.mock._\nimport zio.test.{test, _}\n\ntest("expecting simple value") {\n  val sut     = UserService.totalUsers\n  val mockEnv = MockUserService.TotalUsers(Expectation.value(14))\n  for {\n    total <- sut.provideLayer(mockEnv)\n  } yield assertTrue(total == 14)\n} \n')),(0,o.kt)("h3",{id:"valuef"},(0,o.kt)("inlineCode",{parentName:"h3"},"valueF")),(0,o.kt)("p",null,"Expecting a value based on input arguments:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.mock._\nimport zio.test.{test, _}\n\ntest("an expectation based on input arguments") {\n  val sut     = UserService.recentUsers(3)\n  val mockEnv = MockUserService.RecentUsers(\n    Assertion.isPositive,\n    Expectation.valueF(n =>\n      (1 to n).map(id => User(id.toString, "name")).toList\n    )\n  )\n\n  for {\n    users <- sut.provideLayer(mockEnv)\n  } yield assertTrue(users.map(_.id) == List("1", "2", "3"))\n}\n')),(0,o.kt)("h3",{id:"valuezio"},(0,o.kt)("inlineCode",{parentName:"h3"},"valueZIO")),(0,o.kt)("p",null,"Expecting a value based on the input arguments and also the result of an effectful operation:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.mock._\nimport zio.test.{test, _}\n\ntest("effectful expectation") {\n  val sut     = UserService.recentUsers(3)\n  val mockEnv = MockUserService.RecentUsers(\n    Assertion.isPositive,\n    Expectation.valueZIO(n =>\n      ZIO.foreach(1 to n) { n =>\n        Random\n          .nextUUID\n          .map(id => User(id.toString, s"name-$n"))\n          .provideLayer(Random.live)\n      }.map(_.toList)\n    )\n  )\n\n  for {\n    users <- sut.provideLayer(mockEnv)\n  } yield assertTrue(List("name-1", "name-2", "name-3") == users.map(_.name))\n}\n')),(0,o.kt)("h3",{id:"unit"},(0,o.kt)("inlineCode",{parentName:"h3"},"unit")),(0,o.kt)("p",null,"Expecting simple unit value:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.mock._\nimport zio.test.{test, _}\n\ntest("expecting unit") {\n  val sut     = UserService.remove("1")\n  val mockEnv = MockUserService.Remove(\n    Assertion.isNonEmptyString,\n    Expectation.unit\n  )\n  \n  for {\n    res <- sut.provideLayer(mockEnv).exit\n  } yield assertTrue(\n    res match {\n      case Exit.Success(()) => true\n      case _ => false\n    }\n  )\n}\n')),(0,o.kt)("h3",{id:"failure"},(0,o.kt)("inlineCode",{parentName:"h3"},"failure")),(0,o.kt)("p",null,"Expecting a failure:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.mock._\nimport zio.test.{test, _}\n\ntest("failure expectation") {\n  val sut = UserService.totalUsers\n  val mockEnv = MockUserService.TotalUsers(Expectation.failure("connection failed"))\n  \n  for {\n    total <- sut.provideLayer(mockEnv).exit\n  } yield assertTrue(\n    total match {\n      case Exit.Success(_) =>\n        false\n      case Exit.Failure(cause) =>\n        cause.contains(Cause.fail("connection failed"))\n    }\n  )\n}\n')),(0,o.kt)("p",null,"There are also ",(0,o.kt)("inlineCode",{parentName:"p"},"failureF")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"failureZIO")," variants like what we described for ",(0,o.kt)("inlineCode",{parentName:"p"},"value")," expectation."),(0,o.kt)("h3",{id:"never"},(0,o.kt)("inlineCode",{parentName:"h3"},"never")),(0,o.kt)("p",null,"This expectation simulates a never-ending loop:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.mock._\nimport zio.test.{test, _}\n\ntest("never ending expectation") {\n  val sut     = UserService.totalUsers\n  val mockEnv = MockUserService.TotalUsers(\n    Expectation.never\n  )\n\n  for {\n    r <- Live.live(\n      sut.provideLayer(mockEnv).timeout(500.millis)\n    )\n  } yield assertTrue(r.isEmpty)\n}\n')),(0,o.kt)("h2",{id:"composing-expectations"},"Composing Expectations"),(0,o.kt)("p",null,"We can combine our expectation to build complex scenarios using combinators defined in ",(0,o.kt)("inlineCode",{parentName:"p"},"zio.mock.Expectation"),"."),(0,o.kt)("h3",{id:"and"},(0,o.kt)("inlineCode",{parentName:"h3"},"and")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"and")," (alias ",(0,o.kt)("inlineCode",{parentName:"p"},"&&"),") operator composes two expectations, producing a new expectation to ",(0,o.kt)("strong",{parentName:"p"},"satisfy both in any order"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.mock._\nimport zio.test.{test, _}\n\ntest("satisfy both expectations with a logical `and` operator") {\n  val sut     = UserService.recentUsers(5) *> UserService.totalUsers\n  val mockEnv = MockUserService.TotalUsers(Expectation.value(1)).and(\n    MockUserService.RecentUsers(\n      Assertion.isPositive,\n      Expectation.value(List(User("1", "user"))))\n  )\n\n  for {\n    total <- sut.provideLayer(mockEnv)\n  } yield assertTrue(total == 1)\n}\n')),(0,o.kt)("h3",{id:"or"},(0,o.kt)("inlineCode",{parentName:"h3"},"or")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"or")," (alias ",(0,o.kt)("inlineCode",{parentName:"p"},"||"),") operator composes two expectations, producing a new expectation to ",(0,o.kt)("strong",{parentName:"p"},"satisfy only one of them"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.mock._\nimport zio.test.{test, _}\n\ntest("satisfy one of expectations with a logical `or` operator") {\n  val sut     = UserService.totalUsers\n  val mockEnv = MockUserService.TotalUsers(Expectation.value(1)).or(\n    MockUserService.RecentUsers(\n      Assertion.isPositive,\n      Expectation.value(List(User("1", "user"))))\n  )\n\n  for {\n    total <- sut.provideLayer(mockEnv)\n  } yield assertTrue(total == 1)\n}\n')),(0,o.kt)("h3",{id:"andthen"},(0,o.kt)("inlineCode",{parentName:"h3"},"andThen")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"andThen")," (alias ",(0,o.kt)("inlineCode",{parentName:"p"},"++"),") operator composes two expectations, producing a new expectation to ",(0,o.kt)("strong",{parentName:"p"},"satisfy both sequentially"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.mock._\nimport zio.test.{test, _}\n\ntest("satisfy sequence of two expectations with `andThen` operator") {\n  val sut     = UserService.recentUsers(5) *> UserService.totalUsers\n  val mockEnv = MockUserService.RecentUsers(\n    Assertion.isPositive,\n    Expectation.value(List(User("1", "user")))\n  ) andThen MockUserService.TotalUsers(Expectation.value(1))\n\n  for {\n    total <- sut.provideLayer(mockEnv)\n  } yield assertTrue(total == 1)\n}\n')),(0,o.kt)("p",null,"In the example above, changing the SUT to ",(0,o.kt)("inlineCode",{parentName:"p"},"UserService.totalUsers *> UserService.remove(1)")," will fail the test."),(0,o.kt)("h3",{id:"exact-repetition"},"Exact Repetition"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"strong"},"exactly"))," \u2014 Produces a new expectation to satisfy itself exactly the given number of times:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.mock._\nimport zio.test.{test, _}\n\ntest("satisfying exact repetition of a method call") {\n  val sut     = ZIO.foreach(List("1", "2", "3", "4"))(id => UserService.remove(id))\n  val mockEnv = MockUserService.Remove(\n    Assertion.isNonEmptyString\n  ).exactly(4)\n\n  for {\n    _ <- sut.provideLayer(mockEnv)\n  } yield assertTrue(true)\n}\n')),(0,o.kt)("ol",{start:2},(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"strong"},"twice"))," and ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"strong"},"thrice"))," \u2014 Aliases for ",(0,o.kt)("inlineCode",{parentName:"li"},"exactly(2)")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"exactly(3)"),".")),(0,o.kt)("h3",{id:"range-of-repetitions"},"Range of Repetitions"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"strong"},"Expectation#repeats(range: Range)"))," \u2014 Repeats this expectation within given bounds, producing a new expectation to ",(0,o.kt)("strong",{parentName:"li"},"satisfy itself sequentially given number of times"),":")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.mock._\nimport zio.test.{test, _}\n\ntest("expect repeated calls") {\n  val sut     = Random.nextInt *> Random.nextInt\n  val mockEnv = MockRandom.NextInt(Expectation.value(42)).repeats(2 to 4)\n\n  for {\n    _ <- sut.provideLayer(mockEnv)\n  } yield assertTrue(true)\n}\n')),(0,o.kt)("p",null,"In the example above, if we repeat ",(0,o.kt)("inlineCode",{parentName:"p"},"nextInt")," less than 2 or over 4 times, the test will fail."),(0,o.kt)("p",null,"Another note on repetitions is that, if we compose expectations with ",(0,o.kt)("inlineCode",{parentName:"p"},"andThen"),"/",(0,o.kt)("inlineCode",{parentName:"p"},"++"),", once another repetition starts executing, it must be completed in order to satisfy the composite expectation. For example ",(0,o.kt)("inlineCode",{parentName:"p"},"(A ++ B).repeats(1, 2)")," will be satisfied by either ",(0,o.kt)("inlineCode",{parentName:"p"},"A->B")," (one repetition) or ",(0,o.kt)("inlineCode",{parentName:"p"},"A->B->A->B")," (two repetitions), but will fail on ",(0,o.kt)("inlineCode",{parentName:"p"},"A->B->A")," (incomplete second repetition):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.mock._\nimport zio.mock.Expectation._\nimport zio.test.{test, _}\n\ntest("if another repetition starts executing, it must be completed") {\n  val sut     = Random.nextInt *> Random.nextBoolean *> Random.nextInt\n  val mockEnv = (MockRandom.NextInt(value(42)) ++ MockRandom.NextBoolean(value(true)))\n    .repeats(1 to 2)\n  for {\n    _ <- sut.provideLayer(mockEnv)\n  } yield assertTrue(true)\n} @@ TestAspect.failing\n')),(0,o.kt)("ol",{start:2},(0,o.kt)("li",{parentName:"ol"},"The ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"strong"},"atLeast(min: Int)")),", ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"strong"},"atMost(max: Int)")),", and ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"strong"},"optional"))," expectations are other variants for ",(0,o.kt)("inlineCode",{parentName:"li"},"repeats")," expectation.")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The ",(0,o.kt)("inlineCode",{parentName:"li"},"atLeast")," operator is a lower-bounded variant of ",(0,o.kt)("inlineCode",{parentName:"li"},"repeated"),", produces a new expectation to satisfy ",(0,o.kt)("strong",{parentName:"li"},"itself sequentially at least given number of times"),"."),(0,o.kt)("li",{parentName:"ul"},"The ",(0,o.kt)("inlineCode",{parentName:"li"},"atMost")," operator is an upper-bounded variant of ",(0,o.kt)("inlineCode",{parentName:"li"},"repeated"),", produces a new expectation to satisfy ",(0,o.kt)("strong",{parentName:"li"},"itself sequentially at most given number of times"),"."),(0,o.kt)("li",{parentName:"ul"},"The ",(0,o.kt)("inlineCode",{parentName:"li"},"optional")," operator is an alias for ",(0,o.kt)("inlineCode",{parentName:"li"},"atMost(1)"),", produces a new expectation to satisfy ",(0,o.kt)("strong",{parentName:"li"},"itself at most once"),".")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"MockClock")," is a built-in mock version of the ","[",(0,o.kt)("inlineCode",{parentName:"p"},"Clock"),"]"," service. "),(0,o.kt)("p",null,"Here is an example of mocking ",(0,o.kt)("inlineCode",{parentName:"p"},"Clock.nanoTime")," capability:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.mock._\nimport zio.mock.Expectation._\nimport zio.test.{test, _}\n\ntest("calling mocked nanoTime should return expected time") {\n  val app = Clock.nanoTime\n  val env = MockClock.NanoTime(value(1000L))\n  val out = app.provideLayer(env)\n  out.map(r => assertTrue(r == 1000L))\n}\n')),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"MockConsole")," is a built-in mock version of the ","[",(0,o.kt)("inlineCode",{parentName:"p"},"Console"),"]"," service."),(0,o.kt)("p",null,"Here is an example of mocking ",(0,o.kt)("inlineCode",{parentName:"p"},"Console.readLine")," capability:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.mock._\nimport zio.test.{test, _}\n\ntest("calling mocked readline should return expected value") {\n  for {\n    line <- Console.readLine.provideLayer(\n      MockConsole.ReadLine(Expectation.value("foo"))\n    )\n  } yield assertTrue(line == "foo")\n}\n')),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"MockRandom")," is a built-in mock version of the ","[",(0,o.kt)("inlineCode",{parentName:"p"},"Random"),"]"," service. It mocks all the random service capabilities."),(0,o.kt)("p",null,"Here's how we can mock the ",(0,o.kt)("inlineCode",{parentName:"p"},"MockRandom.nextIntBounded")," capability:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.mock._\nimport zio.test.{test, _}\n\ntest("expect call with input satisfying assertion and transforming it into output") {\n  for {\n    out <- Random.nextIntBounded(1).provideLayer(\n      MockRandom.NextIntBounded(\n        Assertion.equalTo(1),\n        Expectation.valueF(_ + 41)\n      )\n    )\n  } yield assertTrue(out == 42)\n}\n')),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"MockSystem")," is a built-in mock version of the ","[",(0,o.kt)("inlineCode",{parentName:"p"},"System"),"]"," service. It mocks all the system service capabilities."),(0,o.kt)("p",null,"Here's how we can mock the ",(0,o.kt)("inlineCode",{parentName:"p"},"MockSystem.property")," capability:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.mock._\nimport zio.test.{test, _}\n\ntest("calling mocked property should return expected property") {\n  for {\n    property <- System.property("java.vm.name").provideLayer(\n      MockSystem.Property(\n        Assertion.equalTo("java.vm.name"),\n        Expectation.value(Some("OpenJDK 64-Bit Server VM"))\n      )\n    )\n  } yield assertTrue(property.get.contains("OpenJDK"))\n}\n')))}m.isMDXComponent=!0}}]);